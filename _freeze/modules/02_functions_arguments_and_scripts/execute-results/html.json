{
  "hash": "4a0e518a89540bcfe7884ffab1ebc238",
  "result": {
    "markdown": "---\ntitle: \"**Functions, arguments, and R scripts**\"\nauthor: \"Gabriel I. Cook\"\ndate: \"29 December, 2023\"\n\nexecute:\n  #enabled: false\n  freeze: auto\n---\n\n\n\n\n\n\n# **Overview**\n\nA good friend of mine was once tried using R to summarize data. He couldn't figure out why he could not use a function called `mean()` to calculate the mean of variables in his data set. Yes, `mean()` does compute a mean but he did not understand the object for which he was trying to compute a mean. When I explained the issue to him, he told me that he would often try to *'brute force'* his way into obtaining results. He did not understand how the function worked and was not very concerned with learning. Without knowing how functions work, you limit yourself to troubleshoot answers and you spend a lot of time troubleshooting errors. You cannot just brute force yourself into data science or running models without getting yourself into trouble. \n\nThe concepts covered is this section may be challenging or confusing to beginners. You may even question why we cannot just jump into data manipulation and why all of this matters. In order to code in R so that you can be comfortable using it and with communicating with other users, a very basic understanding of programming concepts is important. This way, when someone asks you about an object, function, or assignment, you will know what they are taking about. And, well, you can't communicate with R without knowing how functions work at a basic level. \n \n## **External Functions**\n\nProvided in class:\n\n`view_html()`: for viewing data frames in html format, from `/r/my_functions.R`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(here::here(\"r\", \"my_functions.R\"))\n```\n:::\n\n\nYou can access remotely using this code, though you do not need to do so now.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"https://raw.githubusercontent.com/slicesofdata/fods24/main/r/functions/view_html.R\")\n```\n:::\n\n\n# **Simple Overview of Objects**\n\nLet's talk about **objects**, object **names**, and **assignment** of names to objects. Quite likely, you have been *assigned* a name, whether at birth or shortly thereafter. Typically speaking, you cannot leave the hospital without being given a name to be part of the governments records. As part of this process, you are also assigned a SSN. Of course, you may have been born outside of a hospital and someone forgot to process paperwork on your behalf, in which case there may not be any record of a name assigned to you nor may there be a record of you existing. Unlikely is the case, however. \n\nIn the example above, you are the *object* and a *name* has been *assigned* to you. Names help distinguish you from another person. In programming languages, different names are used to distinguish one object from another object.  \n\n## **Examples of objects**\n\nYou can also think of an *object* as a sort of container that holds something. Containers of different types hold different things and so is true in computer programming. A container for holding water may look different from a container for holding books. In computer speak, one type of container can hold numbers, another can hold characters, another can hold a data frame, etc. The container object is holding whatever you have assigned it to hold.\n\nWe will deal with different types of objects in data science. Without providing too complicated or technical of a description, some are describe below. \n\n- **numeric** objects: representing numeric information (e.g., one's age)\n- **character** objects: representing character information (e.g., one's name or race)\n- **vector** objects: representing more than one numeric object (e.g., ages of participants)\n- **data frame** objects: containing vectors of data (e.g., column variables and row instances of data)\n- **function** objects: that accept one object and return an other object (e.g., the mean of numeric vector)\n\nThere are other type of objects that you will learn about and encounter but for now, those are the most relevant.\n\n\n## **A character example**\n\nLet's start with an example of an object called `name`, which we would like to assign a set of characters, like *Jim Bob*. \n\nIn order to create such an object, we would need to place the characters within quotation marks (e.g., single or double, does not matter). The quotes let R know the contents of `name` are *characters* (aka *strings*). \n\n`\"Jim Bob\"`\n\nWhen dealing with data, you will encounter many character objects as they often represent factor variables (e.g., race, ethnicity, favorite game, etc.) but you will also see lots of objects that are numeric in some form (e.g., age, rating, cognitive performance, etc.).\n\n\n# **Object Assignment**\n\n## **Assignment using `<-`**\n\nBefore we can create any objects, however, we need to understand a little about *assignment*. In computer programming, an assignment statement sets (or re-sets) an object denoted by a name. Assignment requires using an *assignment operator*, which in R is `<-`. In some computer languages `=` is the assignment operator, so R is a little different if you are familiar with other languages. This practice also helps you distinguish between object assignment and other uses of `=` that don't stand for assignment. \n\n**NOTE**: *Technically, you can assign objects with `=` in R but please do not be tempted to do so. If you do this once or twice, that's fine. Making this a practice will cost you. The reason is that *`<-` *and* `=` *behave differently. The one exception is when you are assigning objects inside of a function you create but many of you won't be writing many functions, if any at all.* \n\nPlease use `<-` as this is the practice in the R community. \n\n## **Assignment provides meaning or definition**\n\nIn other words, *assignment* is akin to creating a new word and assigning a meaning to it. You could also think of an assignment statement as a way to tell R to **\"create this thing and set it equal to something\"** so that the computer understand what that represents. \n\n## **A character object: A silly example**\n\nIf objects are like containers holding things, we can use name of the object (e.g., `container`) and then assign `\"things\"` to it using `<-`. In order to create a character object, we would need to place the characters within quotation marks (e.g., single or double, does not matter). The quotes let R know the contents of `container` are *characters* (aka *strings*). \n\n`\"things\"`\n\nWhen dealing with data, you will encounter many character objects as they often represent factor variables (e.g., race, ethnicity, favorite game, etc.) but you will also see lots of objects that are numeric in some form (e.g., age, rating, cognitive performance, etc.).\n\nSilly Example: \n\n- `\"something\"` `assigned` to `container`\n- `container <- \"something\"`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontainer <- \"things\"\n```\n:::\n\n\nAnd to see its contents, use `print()` to return the objects content:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(container)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"things\"\n```\n:::\n:::\n\n\n\nOr just type the name of the object and you will see the returned object is `\"things\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontainer\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"things\"\n```\n:::\n:::\n\n\nFor another example, we could also create an object called `name`, which we could assign a set of characters, like *Jim Bob*, making the object a character object. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nname <- \"Jim Bob\"\n```\n:::\n\n\nTo see what is returned:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Jim Bob\"\n```\n:::\n:::\n\n\nWhether you name is or is not Jim Bob, you can see that `name` contains the characters that represent the name of someone named \"Jim Bob\". Although we assigned `\"Jim Bob\"` to `name`, we could have assigned it a given name. The assignment process simply stores the assigned information as an object using of whatever name you decided to call it (e.g., `name`, `Name`, `NAME`, `xyz`, etc.). We will discuss more on these letter casing differences later. \n\nYou could also assign the character to the object this way.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"things\" -> container\n```\n:::\n\n\nHowever, we won't use much of this approach for different reasons. One reason is that doing so does not follow the [R Style Guide](https://style.tidyverse.org/). The style guide defines a set of guidelines for coding in R. Rather than memorize all of the styling, pay careful attention to the way code appears in the examples provided and try your best to model your code after the examples. For example, don't do something this `container<-\"things\"` just so you save space as doing so makes the code more difficult for you and others to read and understand.\n\nOK, back to *Jim Bob*. Of course, there are different people other than Jim Bob who exist in the world but when coding, they do not exist unless you create them. So, let's create an object that holds the name of `\"Jim Bob\"`.\n\n`name <- \"Jim Bob\"`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname <- \"Jim Bob\"     # assign string to object named name\n\n\nName <- \"Jim Bob\"     # we could have assigned it a different name, say Name\n\n\nNAME <- \"Jim Bob\"     \n```\n:::\n\n\nWhenever you reference the object `name` (or `Name`), R will *return* the contents of the object to you, which in this case will be a character or string object containing a single person's name because that's how we assigned it. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nname               # call object to return contents of \"name\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Jim Bob\"\n```\n:::\n:::\n\n\nAnd again, we can use `print()` to do the same thing:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Jim Bob\"\n```\n:::\n:::\n\n\n### **Being mindful of case sensitivity**\n\nA word of warning is needed here. Although `name`, `Name`, and `NAME` all contain the same four characters, *n* *a* *m* and *e* all arranged it he same order, the objects are all different. They just happen to hold the same content. The reason for there being three different object is because R is a case-sensitive language, which means that the letter case matters. In some programming languages, the case is ignored. \n\nTo illustrate, consider an example for which you assign different names to the object.  \n\n```\nname <- \"Jim Bob\"     # create the object\n\n\nName <- \"Bob\"         # then change it\n\n\nNAME <- \"Jim\"         # then change it again\n```\n\nIn those languages, if you asked what the `name` object contained, the program would return `\"Jim\"` because these characters were assigned last, even though they were assigned to an uppercase version, `NAME`. With R, you will need to be mindful of the letter case. This is by design, perhaps an advantage rather than a disadvantage.\n\n\n## **A numeric object**\n\nWhat about numeric information? We can create an object called `year` and assign the current year to it; let's have this object contain the current year in numeric form, not as a string. Remember to use `<-` for assignment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyear <- 2024    # assign a number to year ; notice no quotes\n```\n:::\n\n\nIn order to know whether this `year` object now contains the year, we can check by typing the name of the object or use `print()` to print the returned value.   \n\n\n::: {.cell}\n\n```{.r .cell-code}\nyear\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2024\n```\n:::\n\n```{.r .cell-code}\nprint(year)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2024\n```\n:::\n:::\n\n\n## **Inspecting vectors with some functions**\n\n`name` and `year` are very simple objects. `name` is a simple character/string object we created, which contains only the name of 1 person and `year` only holds the current year. There is something else important about how R treats them that you cannot see on the surface. Both of these objects are also **vectors**. Vectors are *one-dimensional arrays* containing *n* pieces of information. You might also think of a vector so a variable (e.g., IQs of people). Both the `name` and `year` vectors contain only one piece of information, however. If you don't believe me, we can use some functions that will answer this for us. \n\n- `is.vector()` is a function that returns a logical (T or F) about whether the object is a vector\n- `length()` is a function that returns a non-negative numeric integer representing the number of elements contained \n- `typeof()` is a function that returns the object's type \n\nLet's try them by passing the object `name` inside the function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.vector(name)   # is it a vector?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n#?length\nlength(name)      # how many elements?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\ntypeof(name)      # what is it's type?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nIf `name` contained more than one object, it would still be a vector having a different length. But in order to create such vectors, each **element** of the vector needs to be separated by a comma and each elements needs to be wrapped by quotes. \n\nIf you do not separate strings by a comma...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname <- \"Jim Bob Kendra\"\n\n\nname                                # return object; also print(name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Jim Bob Kendra\"\n```\n:::\n\n```{.r .cell-code}\nis.character(name)                  # is it a character?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nlength(name)                        # what is its length?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n\nIf you do use quotes for each element and separate each by a comma, you need to use a function to combine them, which is `c()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname <- c(\"Jim Bob\", \"Kendra\")  # two names, combine with c()\n\n\n\nis.character(name)        \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nlength(name)                   # vector with length 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nThe more you work with character vector, the more you way want to avoid some annoyances of creating them.\n\nThe **{Hmisc}** library has a function called `Cs()` that obviates the inclusion of the quotes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHmisc::Cs(Jim, Kendra, Bill, Sandy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Jim\"    \"Kendra\" \"Bill\"   \"Sandy\" \n```\n:::\n:::\n\n\nBeware of vectors containing elements with space like this:\n\n`Hmisc::Cs(Jim Bob, Kendra)`\n\nR will throw an error to inform you that something is wrong. For example: `Error: unexpected symbol in \"Hmisc::Cs(Jim Bob\"`.\n\n## **Elements of vectors**\n\nAs a side note, the pieces/values of a vector are referred to as **elements**. You can reference elements by number representing their position in the vector. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nname[1]   # first element\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Jim Bob\"\n```\n:::\n\n```{.r .cell-code}\nname[2]   # second element\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Kendra\"\n```\n:::\n\n```{.r .cell-code}\nname[3]   # a third element? No. It only has length 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nObjects in R, however, can take on many forms other than strings or numbers just illustrated. Objects can be strings/characters, numeric values, character strings, functions, data frames, vectors, lists, matrices, plots, etc. If you use `typeof()` on a data frame object, the function will return `\"list\"` because a data frame is also a list. More on this later. \n\n\n# **Function Characteristics**\n\nWe have used some functions like `is.vector()` and `length()` to inspect some objects above. Given our reliance on function in this course, there is some terminology to understand how to work with functions. \n\nHere are 5 terms/concepts to know:\n\n- *name* (created by assignment operator `<-`)\n- *definition* (code statements or instructions for its usage)\n- *function arguments* (optional variables that specify the function's operation)\n- *function call* (e.g., execution of a function)\n- *returned object* (value returned from the executed function)\n\n\n# **Functions are Objects with Names and Definitions**\n\nIn computer language, *functions* are also objects and like all objects are *assigned* names. These names help distinguish one function from another because each function will serve a different purpose. If you are thinking that some people can have the same name even though they are different objects, yes, some functions can have the same name even though they refer to different objects.\n\nThe object examples above for `name` and `year` illustrated creation of a string object or a numeric value. These objects didn't perform any operation, mathematical or otherwise. Functions are special types of objects that carry out certain operations for you, like calculate a mean, a standard deviation, or run all the math for a linear model used for regression or ANOVA. These function objects are essentially containers that perform computations for you.\n\nThink of functions like words with definitions. The definition is what the function does/means/stands for and the word is what the function is named. For example, a function to calculate the *mean* of a numeric vector is called `mean` and its definition is the formula for calculating an arithmetic mean. \n\n`R` has built-in functions, functions as part of external `libraries` (or packages), and functions that you define yourself. The term function means exactly what you might expect - code that executes some type of *function*.  In R, functions are easily *called* by placing parentheses, `()`, at the end of the function name (e.g., `mean()`). Within the parentheses are any arguments you will need to specify corresponding to the functions parameters. More on arguments later, so just hold on.  \n\n\n# **Objects and Function Objects**\n\nNow that you have a basic idea of objects and assignment, there are different types of objects. Unlike the example of assigning a value to an object, functions like `mean()`, `c()`, `data.frame()` and `mutate()` are objects that contain statements for carrying out operations. As you might imagine, calculating the mean of a set of values using the `mean()` function would involve statements to carry out operations like summation and division. \n\n- `mean()`: to compute the mean of a numeric vector\n- `c()`: to combine elements into a vector\n- `data.frame()`: to create a data frame\n- `dplyr::mutate()`: for creating variables in data frames\n\n\n# **Understanding Functions by Writing Them** \n\nThe *function* function: `function()`\n\nOne way to understand how functions work is to create some yourself. Because functions are objects, you would assign (e.g., using `<-`) code to the function object. Let's create some functions using the function named `function()`, which is required in order to create function. This function is aptly named for its purpose. When using `function()`, you are telling R that the statements that follow are part of a function. The statements you will put between `{` and `}`. \n\nLet's create *2* functions by assigning their contents to objects named `func_a` and `func_b`. In order for functions to `return` the result of their operation(s), we will also need to use the `return()` function as part of the functions statements. Though not a requirement of all functions, if you ever have to write functions, including `return()` eliminates ambiguity of what the function call returns.\n\n\n*Define* function definition and *assign* to function *name*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc_a <- function() {\n  return(2022)         # This silly function contains a simple statement; to return a specific numeric value\n}\n\n\nfunc_b <- function() {\n  return(\"2022\")       # This silly function simple returns a string representing the current year\n}\n```\n:::\n\n\n\n# **Function Versus the Function Object**\n\nFunctions are called by appending `()` to their assigned name. Objects that are not functions don't operate the same way. If you wish to call a function, you need to append parentheses to the name. Without them, the R interpreter will provide you with the functions contents and details about the function itself.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc_a      # If you don't use the (), you'll just see the contents of the function object \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction() {\n  return(2022)         # This silly function contains a simple statement; to return a specific numeric value\n}\n```\n:::\n\n```{.r .cell-code}\nfunc_b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction() {\n  return(\"2022\")       # This silly function simple returns a string representing the current year\n}\n```\n:::\n:::\n\n\n\nAdd `()` to call the function and see what R returns to you.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc_a()    # Call the function and see it return something \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2022\n```\n:::\n\n```{.r .cell-code}\nfunc_b()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022\"\n```\n:::\n:::\n\n\n\n# **Performing Operations on Objects**\n\nBecause `func_a()` returns a numeric object, you can perform mathematical operations on it just as you would any numeric object. You cannot perform mathematical operations on character or string objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc_a() + 2    # the year plus 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2024\n```\n:::\n\n```{.r .cell-code}\nfunc_a() * 2    # twice the year\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4044\n```\n:::\n\n```{.r .cell-code}\n#func_b() + 2    # the interpreter does not understand this and reports an error.\n\n\n\n#func_b() * 2\n```\n:::\n\n\n\n# **Function Parameters and Arguments**\n\nNotice that you didn't need to include any of your own instructions for these functions to perform their operations. Although some functions in R operate this way, many will require some additional values or variables. Functions that have `parameters` as part of their code statements will require you to pass `arguments` to be used in those statements. \n\nIn many context, people will not differentiate between parameters and arguments. There is a difference, which I will point out briefly here.\n\nParameters versus arguments\n\n- A function's parameters are the names listed in the function's definition.\n- A function's arguments are the actual values passed to the function.\n\n# **An example with `length()`**\n\nExample:\n\n- `length` is a function; see `help(length)`\n- `length` has one *parameter*, `x`, which needs to be a vector or factor\n\nIn order for the function to return the number of elements in the vector, you will need to pass an argument of real or actual values to the `x` parameter. For example, your argument is the actual vector you assigned to `x` in the function. \n\nThus the *argument* is the value passed to the parameter as shown here:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(x = c(\"Bob\", \"Jim\", \"Sally\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nThe **returned** value is the integer representing the number of elements.\n\n# **An example with `mean()`**\n\nFor example, `mean()` will require you to pass a numeric vector in order to calculate the *mean* of those the elements in the vector If you do not pass an argument, R will not know know what to calculate the mean for and it will throw an error. If you check `?mean`, you will see that `x` is the parameter requiring some argument of values. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#mean()               # nothing passed to function; error\n\n\nmean(x = c(1,2,5) )   # vector passed as argument to parameter x; mean of vector returned \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.666667\n```\n:::\n\n```{.r .cell-code}\nmean( c(1,2,5) )      # x is not needed because it's the first parameter\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.666667\n```\n:::\n:::\n\n\nBack to parameters. Let's create another function to demonstrate the usage. We will add a single parameter within the parentheses. This parameter has no default value so in order for the function to work, you'd need to pass an argument.  \n\n`func_c <- function(parameter) {`\n    `code statements to do something`\n    \n    `return something`\n`}`\n\n\nSpecify the parameter as `a` or whatever you wish.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc_c <- function(a) {\n  return(a + 2)  # add 2 to what is passed to parameter a \n}\n```\n:::\n\n\n\nCall the function and see what the function call returns...\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#func_c()       # call the function but forgot to give parameter a an argument value  \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc_c(a = 1)    # call the function by setting parameter = 1 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n\nRedefine a function. Note, this will overwrite the previous definition of `func_c()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc_c <- function(a) {\n  b <- a + 2    # add 2 to what is passed to parameter a and assign to object b\n  \n  return(b)     # then return object b\n}\n```\n:::\n\n\nCall the function and see what the function call returns...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc_c         # see what the function is doing\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction(a) {\n  b <- a + 2    # add 2 to what is passed to parameter a and assign to object b\n  \n  return(b)     # then return object b\n}\n```\n:::\n\n```{.r .cell-code}\nfunc_c(a = 1)  # call func_c() setting the argument for parameter a = 1 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n\n# **Name Functions in Useful Ways**\n\nOf course, naming the function `func_c` does not really help you understand what tasks the function is executing. Rather, you may wish to name the function **add2** or something useful and also change the name of the parameter to something meaningful, like `value`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd2 <- function(value) {\n  return(value + 2)  # add 2 to the value argument  \n}\n```\n:::\n\n\nCall the function, passing `value = 7`...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd2(value = 7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n:::\n\n\n\nUnlike the other functions, because `add2()` contains a *parameter* for which you pass an *argument*. Whereas the parameter is part of the function definition, you will need to specify the information to pass to it so that the function knows how to carry out the instructions. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#add2()       # No argument passed, Hmm, error. Note: remove # to test.\n```\n:::\n\n\n\n# **Passing Objects as Function Arguments**\n\nBecause you created an object named `year` earlier, R knows this exists. You could pass this object as an argument to a function assuming it is of the type the function needs. For example, if the function is performing addition, the object passed needs to take a numeric form. Also, because this silly function contains only one argument, we don't need to specify the argument by name. We can simply drop out the argument and pass the object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc_c(a = year)   # passing an argument that is an object\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2026\n```\n:::\n\n```{.r .cell-code}\nfunc_c(year)       # dropping out of the argument by name \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2026\n```\n:::\n:::\n\n\nYou could also pass some other value as an argument or even a mathematical operation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc_c(4)      # pass a number as an argument\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\nfunc_c(10 * 1) # a mathematical operation, though odd perhaps\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12\n```\n:::\n\n```{.r .cell-code}\n#func_d(\"two\")  # but not a string. Note: remove the # to test.\n```\n:::\n\n\n\n# **Functions with Default Arguments**\n\nJust for clarity, if a parameter has a default argument value, you don't need to set an argument but if you do, it will be used in lieu of the default.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc_c <- function(x = 2021) {  # assign x to 2021 as default\n  return(x + 2)                 # add 2 to x\n}\n```\n:::\n\n\n\nCall the function...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc_c()        # not specifying the argument will assume the default value (e.g., 2021)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2023\n```\n:::\n\n```{.r .cell-code}\nfunc_c(10)      # specifying a value will override the default\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12\n```\n:::\n:::\n\n\n\n# **Functions with Multiple Parameters/Arguments**\n\nMany functions have multiple parameters and can thus take multiple arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_xy <- function(x = NULL, \n                   y = NULL) {  # two arguments, each set to NULL as default\n  return(x + y)   \n}\n```\n:::\n\n\n\nCall the function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_xy()      # summing two NULL values (the default) is nothing\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninteger(0)\n```\n:::\n\n```{.r .cell-code}\nsum_xy(2021, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2023\n```\n:::\n\n```{.r .cell-code}\nsum_xy(year, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2026\n```\n:::\n:::\n\n\n\n# **Sourcing code with `source()`**\n\n`source()` is a function that will read and execute R code. One benefit of this function relates to having files of code. Let's say you create an R script file with extension `.R` (see **RStudio -> File -> New File -> R Script**) and that file contains R code to read a data file, or clean up variables in a data frame, or create plot objects. All of the code in that `.R` file can be executed from the R console, from within another `.R` file, or from a `.Rmd` file. As result, `source()` can be used to compartmentalize code serving different purposes and to keep each file from being too busy or complicated. Let's try. \n\nCreate an `.R` script file from `RStudio`. In it, type `message(\"My first script file.\")` and save it as `my_first_script` (the `.R` should be automatic) in your `\"/r\"` directory. \n\nBecause the `.Rmd` file you are working with is already saved in `\"/r\"` (if you saved it there correctly), you can source the file by name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(here::here(\"r\", \"my_first_script.R\"))   # runs code saved in \"my_first_script.R\" file; print message\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nMy first script file.\n```\n:::\n:::\n\n\n\n# **Using Functions from Libraries**\n\nFunctions in base `R` are easy to operate on data out of the box; they don't require installation. For example, `head()` will look a the first few rows (or cases) of data frame. A data frame contains n rows and m columns. In order to demonstrate this, we will use the `USArrests` data set that is part of base R. Then, we will use `mean()` to calculate the mean of a vector of data. A column of a data frame is a vector of some type (e.g., numbers or characters).  \n\n- `head()` returns the top of the data frame; compare to `tail()`\n- `View()` (uppercase V): returns a table of the data frame; built into R, looks crappy, steals focus\n- `view_html()` (lowercase v): returns an filterable html table of the data frame; my alternative to `View()` \n\nFor now, know that you can `source()` the raw code from the course site using the following code. Because I use this function often, we will want to add it to your `\"/r/functions\"` directory.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"https://raw.githubusercontent.com/slicesofdata/fods24/main/r/functions/view_html.R\")\n```\n:::\n\n\nIf you query the function in the console by typing using `?head` or `help(head)`, you will see in there are two main parameters. \n\n- `x`: a vector or data frame object \n- `n`: a value of the indices to be selected (e.g., elements of vector, rows in data frame) \n\n`head()` needs an object `x` in order to do anything. We can pass the `USArrests` data frame as the argument and if all goes well, we will only see the top or *head* of this data frame.   \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(x = USArrests)   # 6 rows by default\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Murder Assault UrbanPop Rape\nAlabama      13.2     236       58 21.2\nAlaska       10.0     263       48 44.5\nArizona       8.1     294       80 31.0\nArkansas      8.8     190       50 19.5\nCalifornia    9.0     276       91 40.6\nColorado      7.9     204       78 38.7\n```\n:::\n:::\n\n\nAnd if you pass arguments to parameters in function according to their order (e.g., position), you do not need to reference the parameters by name when passing arguments. For example, we can remove the reference to `x`.   \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(USArrests)   # 6 rows by default\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Murder Assault UrbanPop Rape\nAlabama      13.2     236       58 21.2\nAlaska       10.0     263       48 44.5\nArizona       8.1     294       80 31.0\nArkansas      8.8     190       50 19.5\nCalifornia    9.0     276       91 40.6\nColorado      7.9     204       78 38.7\n```\n:::\n:::\n\n\nThe second parameter for `head()` is `n`, the number of rows for the function to return. The default number was 6. We can change the default operation by passing `3` as the argument to it.\n\n\n\n\n\nBut as long as we pass the arguments to `x` and then to `n`, then we do not need to reference either by name. Instead, we can just pass the arguments.\n\n\n\n\n\nBut if you change order, you will need to reference the arguments. You cannot call `head(3, USArrests)` for example but you can call `head(n = 3, x = USArrests)`. You normally would not wish to change the order of arguments for `head()` but for more complicated functions, you might wish to for different reasons. \n\n\n\n\n\nUsing the viewing options:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#View(USArrests)                            # the standard viewer\n\n#view_html(USArrests, rows = T, show = 5)   # but same as \n\n#view_html(head(USArrests), rows = T)\n```\n:::\n\n\n\nYou can also check whether the `USArrests` data file is a data frame using `is.data.frame()`, which will return `TRUE` indicating that it is indeed a data frame. \n\n- `is.data.frame()` returns logical ( T or F) about data frame as two-dimensional array\n\n\n\n\n\n\nThat seems tedious, however. You can learn a lot more about the data frame by examining its structure using `str()`. The `USArrests` object is a data frame, contains 50 observations (e.g., rows) and 4 variables (columns). All column variables appear to contains numbers, with two of them being numeric, abbreviated `num` and two are integers, abbreviated `int`. \n\n- `str()` returns the structure of a data frame\n\n\n\n\n\nAnd you can check the names of the columns using `names()`. What is actually returned to you is a character vector, or a vector whose elements are of character type. You can test whether the column names is a vector by *wrapping* `names()` with the `is.vector()` function. Similarly, wrapping `names()` in `typeof()` will tell you the type is `character`. \n\n- `names()` returns names of data frame\n- `is.vector()` returns logical if/if not a vector (see other `is.` functions)\n- `typeof()` returns the type of the object\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(USArrests)           # what are the names of the columns?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Murder\"   \"Assault\"  \"UrbanPop\" \"Rape\"    \n```\n:::\n\n```{.r .cell-code}\nis.vector(names(USArrests))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\ntypeof(names(USArrests))   # what is type of structure are the names\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n\n\n# **Session Information**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 11 x64 (build 22621)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/Los_Angeles\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] utf8_1.2.4         generics_0.1.3     stringi_1.8.3      digest_0.6.33     \n [5] magrittr_2.0.3     evaluate_0.23      grid_4.3.2         fastmap_1.1.1     \n [9] rprojroot_2.0.4    jsonlite_1.8.8     processx_3.8.3     nnet_7.3-19       \n[13] backports_1.4.1    Formula_1.2-5      ps_1.7.5           gridExtra_2.3     \n[17] fansi_1.0.6        scales_1.3.0       cli_3.6.2          rlang_1.1.2       \n[21] munsell_0.5.0      Hmisc_5.1-1        base64enc_0.1-3    yaml_2.3.8        \n[25] tools_4.3.2        checkmate_2.3.1    htmlTable_2.4.2    dplyr_1.1.4       \n[29] colorspace_2.1-1   ggplot2_3.4.4      webshot_0.5.5      here_1.0.1        \n[33] vctrs_0.6.5        R6_2.5.1           rpart_4.1.23       lifecycle_1.0.4   \n[37] stringr_1.5.1      htmlwidgets_1.6.4  foreign_0.8-86     cluster_2.1.6     \n[41] pkgconfig_2.0.3    callr_3.7.3        pillar_1.9.0       gtable_0.3.4      \n[45] glue_1.6.2         data.table_1.14.10 xfun_0.41          tibble_3.2.1      \n[49] tidyselect_1.2.0   rstudioapi_0.15.0  knitr_1.45         htmltools_0.5.7   \n[53] rmarkdown_2.25     compiler_4.3.2    \n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}