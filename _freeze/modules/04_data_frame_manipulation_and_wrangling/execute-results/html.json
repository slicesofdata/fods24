{
  "hash": "6cc5cfeab7b347fb565dfc1518408b74",
  "result": {
    "markdown": "---\ntitle: \"**Data frame manipulation and wrangling**\"\nauthor: \"Gabriel I. Cook\"\n#date: \"2023-12-18\"\ndate: \"18 December, 2023\"\n\nexecute:\n  #enabled: false\n  freeze: auto\n  \n# this is a test to figure out why there is the following error when rendering many quarto files:\n# ERROR: The filename, directory name, or volume label syntax is incorrect. (os error 123)\n---\n\n\n::: callout-important\n## Under construction. \n\nThis page is a work in progress and may contain areas that need more detail or that required syntactical, grammatical, and typographical changes. If you find some part requiring some editing, please let me know so I can fix it for you.\n\n:::\n\n\n\n\n\n# **Overview**\n\nThis module demonstrates how to use **{dplyr}** to wrangle data frames. There is much that you can do with the library and this module focuses on selecting, filtering, and arranging data frames or tibbles. Helper functions from libraries like **{magrittr}**, **{stringr}**, and **{tidyselect}** are also used in conjunction with **{dplyr}**.\n\n## **Libraries** \n\n\n- **{here}**: 1.0.1: for path management\n- **{dplyr}** 1.1.2: for selecting, filtering, and mutating\n- **{magrittr}** 2.0.3: for code clarity and piping data frame objects\n- **{stringr}**: 1.5.0: for working with strings\n- **{tidyselect}**: 1.2.0: for selecting sets from strings\n\n## **External Functions**\n\nProvided in class:\n\n`view_html()`: for viewing data frames in html format, from `/r/my_functions.R`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(here::here(\"r\", \"my_functions.R\"))\n```\n:::\n\n\n## **Libraries**\n\nWe will work with a few different libraries for data manipulation. Let's load them into our work space using `library()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magrittr)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(stringr)\n```\n:::\n\n\nMake note of any warnings that appear when loading libraries. There are some libraries that contain functions with the same names. Be aware that the most recently loaded library function will take precedence. You can avoid confusion using `::` to call a function from a particular library (e.g., `libraryname::functionname()`).\n\n\n# **A Grammar for Data Wrangling** \n\nThe [**{dplyr}**](https://dplyr.tidyverse.org/) package presents a type of grammar for wrangling data ([Wickham *and* Francois 2014](https://www.researchgate.net/publication/275646200_dplyr_A_Grammar_of_Data_Manipulation)). **{dplyr}** is part of the [**{tidyverse}**](https://www.tidyverse.org/) ecosystem which loads using `library(tidyverse)`, or specifically using `library(dplyr)`. **{dplyr}** also imports functions from **{tidyselect}**, which is also part of the **{tidyverse}** ecosystem.\n\nThe functions from any `R` package can be called after loading the package library. One does not need to reference the package explicitly when calling a function but to avoid confusion, we will often reference the package/library and the function together (e.g., `package::function()`).\n\nWorking with data involves creating new column variables, removing or renaming column variables, removing or deleting row observations, sorting, and summarizing data (often by groups/factors). etc. Consequently, there are five main function verbs for working with data in a data frame: `select`, `filter`, `mutate`, `arange`, and `summarize`. Their corresponding functions are:\n\n- `select(dataframe, variables_to_select)`: subset by columns \n- `mutate(dataframe, variables_to_create)` and `dplyr::rename()`: add or modify existing columns\n- `filter(dataframe, rows_to_select)`: subset by rows\n- `arrange(dataframe, variable_to_sort_by)`: sort rows\n- `summarize(dataframe, procedures_for_summarizing)` in conjunction with `dplyr::group_by()`: aggregate the data in some way\n\n\n# **Some Common Ways for Selecting Variables Using `{dplyr}`**\n\nYou can reference variables by their names or by their column position in a data frame (e.g., 1, 25, etc.). \n\nUsing `select()`, you can select columns/variables from a data frame. The variables you select are retained and variables omitted that you don't select are omitted in the returned data frame. \n\nIf you are not piping a data frame from a previous object using either `|>` (now in base `R`) or  `%>%` (from **{magrittr}**), the first argument passed into `select()` will be the data frame. The second and subsequent arguments can be column variables you wish to select from the data frame. \n\n```\nselect(mydataframe, myvars)\n```\n\nIf piping a data frame with **{magrittr}**, `.` or `.data` will serve to reference the inherited data frame. This detail is not needed but adding it serves as a reminder that the data frame is the first argument of the function. \n\n```\ndataframe %>%\n   select(., myvars)\n```\n\nVariables can be passed by their column position.\n\n*Passing variables separately by name:*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nUSArrests %>% \n  select(., 1, 3) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Murder UrbanPop\nAlabama      13.2       58\nAlaska       10.0       48\nArizona       8.1       80\nArkansas      8.8       50\nCalifornia    9.0       91\nColorado      7.9       78\n```\n:::\n:::\n\n\nVariables can be passed separately without quotes or collectively as a character vector.\n\n*Passing variables separately by name:*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nUSArrests %>% \n  select(., Murder, Assault) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Murder Assault\nAlabama      13.2     236\nAlaska       10.0     263\nArizona       8.1     294\nArkansas      8.8     190\nCalifornia    9.0     276\nColorado      7.9     204\n```\n:::\n:::\n\n*Note:* passing variables by name does not work with `base R` manipulation, you need to pass the name as a string.\n\n\n*Passing variables separately as characters:*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nUSArrests %>% \n  select(., \"Murder\", \"Assault\") %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Murder Assault\nAlabama      13.2     236\nAlaska       10.0     263\nArizona       8.1     294\nArkansas      8.8     190\nCalifornia    9.0     276\nColorado      7.9     204\n```\n:::\n:::\n\n\n\n*Passing a character vector (more like you would do in `base R`):*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nUSArrests %>% \n  select(., c(\"Murder\", \"Assault\")) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Murder Assault\nAlabama      13.2     236\nAlaska       10.0     263\nArizona       8.1     294\nArkansas      8.8     190\nCalifornia    9.0     276\nColorado      7.9     204\n```\n:::\n:::\n\n\n*Passing a numeric vector of column positions:*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nUSArrests %>% \n  select(., c(1, 3)) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Murder UrbanPop\nAlabama      13.2       58\nAlaska       10.0       48\nArizona       8.1       80\nArkansas      8.8       50\nCalifornia    9.0       91\nColorado      7.9       78\n```\n:::\n:::\n\n\n*Passing an object holding a character vector containing two elements:*\n\nFirst, creat the vector object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkeep_vars <- c(\"Murder\", \"Assault\")\n```\n:::\n\n\nThen pass the vector into the function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nUSArrests %>% \n  select(., keep_vars) %>% head()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nâ„¹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %>% select(keep_vars)\n\n  # Now:\n  data %>% select(all_of(keep_vars))\n\nSee <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n           Murder Assault\nAlabama      13.2     236\nAlaska       10.0     263\nArizona       8.1     294\nArkansas      8.8     190\nCalifornia    9.0     276\nColorado      7.9     204\n```\n:::\n:::\n\n\n\n## *Select Variables Starting with or Ending with Certain Characters*\n\nOne thing about **{dplyr}**, when you load the library, there are functions from other libraries that are imported along with **{dplyr}**'s own functions. These important functions are designed to work with each other, so the people who maintain the libraries have packaged them up nicely so you don't have to load separate libraries. \n\nMany of the functions are imported from the **{tidyselect}** library and these functions are what give you additional manipulation ability. Some imported functions are: `all_of()`, `any_of()`, `contains()`, `ends_with()`, `everything()`, `last_col()`, `matches()`, and `starts_with()`.\n\nWith functions like `starts_with()`, `contains()`, and `ends_with()`, you can select variables with character patterns in their names.\n\nRather that passing the names of the variables as the second argument (e.g., `c(\"Murder\", \"Assault\")`), you would pass the helper function, say `starts_with()`. Whatever `starts_with()` returns is what gets passed to `select()` as the variables. This is what is referred to as functional programming. Rather than coding specifically what to do, you with utilize the task of another function to passed its returned object as an argument to another function.  \n\nBut first, we need to see what these functions, like `starts_with()`, are doing. For more information, use `?starts_with`.\n\n`starts_with(match, ignore.case = TRUE, vars = NULL)`\n\nNotice the arguments we need to pass: \n\n- `match`: A character vector\n- `ignore.case`: If `TRUE`, the default, ignores case when matching names. This is most flexible.\n- `vars`: A character vector of variable names. If not supplied, the variables are taken from the current selection context (as established by functions like `select()` or `pivot_longer()`).\n\nLet's just try out `starts_with()` on its own. Let's set a required pattern `match = some character` and because `vars = NULL` by default, let's just set `vars = some character vector`. Note that `vars` is not the second argument, so you will want to name it in the function call. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstarts_with(match = \"a\", vars = c(\"Hello\", \"Hi\", \"Bye\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninteger(0)\n```\n:::\n:::\n\n\nReturns `integer(0)` which is speak for \"there is no match\". Hmm, OK. Let's try another character.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstarts_with(match = \"b\", vars = c(\"Hello\", \"Hi\", \"Bye\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nOK, so now an integer is returned (yes, try `is.integer()` if you don't believe me). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.integer(starts_with(\"b\", vars = c(\"Hello\", \"Hi\", \"Bye\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nImportantly, the value refers to the element index/position in the `vars` vector. Because the third string `\"Bye\"` starts with `\"b\"`, that's what is returned. \n\nTry something else:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstarts_with(\"h\", vars = c(\"Hello\", \"Hi\", \"Bye\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n:::\n\n\nNow a vector with length = 2 is returned, representing both the first and the second elements start with \"h\". \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(starts_with(\"h\", vars = c(\"Hello\", \"Hi\", \"Bye\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nSee, it's really a vector containing the element(s) of the `vars` vector matching the pattern. \n\nAnd yes, this the letter casing is ignored because the default `ignore.case = TRUE`. Set to `FALSE` if you want your match to be case sensitive.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstarts_with(\"h\", \n            vars = c(\"Hello\", \"Hi\", \"Bye\"), \n            ignore.case = F\n            )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninteger(0)\n```\n:::\n:::\n\n\nOK, no matches.\n\nYou will typically use `starts_with()` along with other functions. When using `starts_with()` in the context of `select()`, the `vars` argument is essentially passing `vars = the names of the columns of the data frame passed to select()`.\n\nExample:\n\n```\nselect(mydataframe,\n    starts_with(match = \"my pattern\",\n                vars = \"var names of mydataframe\")\n                )\n```\n\nPassing the `data frame` into `select()` without piping it using `%>%`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(USArrests, starts_with(\"m\")) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Murder\nAlabama      13.2\nAlaska       10.0\nArizona       8.1\nArkansas      8.8\nCalifornia    9.0\nColorado      7.9\n```\n:::\n:::\n\n\nPiping the `data frame` into `select()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nUSArrests %>%\n  select(., starts_with(\"m\")) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Murder\nAlabama      13.2\nAlaska       10.0\nArizona       8.1\nArkansas      8.8\nCalifornia    9.0\nColorado      7.9\n```\n:::\n:::\n\n\nAnother example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nUSArrests %>%\n  select(., ends_with(\"t\")) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Assault\nAlabama        236\nAlaska         263\nArizona        294\nArkansas       190\nCalifornia     276\nColorado       204\n```\n:::\n:::\n\n\n\n## *Selecting and Selecting Out Variables By/Between Index*\n\nThere are many approaches for *selecting* or *selecting out* column variables. You can pass multiple arguments for each specification or you can pass a single vector that contains all specifications.  \n\n- `select(., 1,2)`: select first and second columns\n- `select(., c(1,2))`: select first and second columns\n- `select(., -c(1,2))`: select out first and second columns\n\n- `select(., 1:2)`: select first through second columns\n- `select(., c(1:2))`: select first through second columns\n- `select(., -c(1:2))`: select out first through second columns\n\n*Potential Recommendation*: use options utilizing `c()` to pass a vector because this habit will be more versatile with `base R` functionality. However, online solutions will likely not take this approach.\n\n\nLet's make a data frame to work with first.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT <- data.frame(\n  Id  = c(100, 101, 102, 103, 104, 100, 105),\n  Sex = c('male', 'female', 'Male', NA, 'man', \"male\", \"neither\"),\n  Age = c(25, 33, 27, 40, 44, 25, 40),\n  Renting = c(\"yes\", NA, \"yes\", NA, \"no\", \"yes\", \"yes\")\n)\n```\n:::\n\n\nSelect columns 1 and 2: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  select(., 1,2) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex\n1 100    male\n2 101  female\n3 102    Male\n4 103    <NA>\n5 104     man\n6 100    male\n7 105 neither\n```\n:::\n:::\n\n\nSelect columns 1 and 2 as a vector containing values 1 and 2:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  select(., c(1,2)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex\n1 100    male\n2 101  female\n3 102    Male\n4 103    <NA>\n5 104     man\n6 100    male\n7 105 neither\n```\n:::\n:::\n\n\nSelect out columns 1 and 2 as a vector containing values 1 and 2:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  select(., -c(1,2)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Age Renting\n1  25     yes\n2  33    <NA>\n3  27     yes\n4  40    <NA>\n5  44      no\n6  25     yes\n7  40     yes\n```\n:::\n:::\n\n\nSelect from columns 1 to 2 using the `:` operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  select(., 1:2) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex\n1 100    male\n2 101  female\n3 102    Male\n4 103    <NA>\n5 104     man\n6 100    male\n7 105 neither\n```\n:::\n:::\n\n\nSelect from columns 1 through 3 using a vector containing the `:` operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  select(., c(1:3)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age\n1 100    male  25\n2 101  female  33\n3 102    Male  27\n4 103    <NA>  40\n5 104     man  44\n6 100    male  25\n7 105 neither  40\n```\n:::\n:::\n\n\nSelect out columns 1 through 3 using a vector containing the `:` operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  select(., -c(1:3))   # select out from here to there\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Renting\n1     yes\n2    <NA>\n3     yes\n4    <NA>\n5      no\n6     yes\n7     yes\n```\n:::\n:::\n\n\n\n## *Selecting and Selecting Out Variables By or Between Character Name*\n\nThese approaches are similar to those offered earlier except that some involve passing variables by their name (e.g., character names). Whereas the order of the variables in a data frame may move around, the names may be more stable or permanent, at least after you have cleaned up the names. Consequently, passing variables by name may be more foolproof. \n\nYou don't have to be familiar with all approaches and you may settle on using one that makes the most sense to you.\n\n- `select(., \"var1\", \"var2\")`\n- `select(., c(\"var1\", \"var2\"))`\n- `select(., -c(\"var1\", \"var2\"))`\n\n- `select(., var1:var2))`\n- `select(., c(\"var1\":\"var2))`\n- `select(., -c(\"var1\":\"var2))`\n\n*Recommendation*: use options utilizing `c()` as this will be more versatile with `base R` functionality.\n\nThese approaches also work but they may lead to some confusion regarding usage of quotes:\n\n- `select(., var1, var2)`\n- `select(., c(var1, var2))`\n- `select(., -c(var1, var2))` \n\n\nSelect variables `Id` though `Age` using the `:` operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  select(., Id:Age) # select from here to there\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age\n1 100    male  25\n2 101  female  33\n3 102    Male  27\n4 103    <NA>  40\n5 104     man  44\n6 100    male  25\n7 105 neither  40\n```\n:::\n:::\n\n\nSelect variables `Id` though `Age` passed as strings using the `:` operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  select(., \"Id\":\"Age\") # select from here to there\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age\n1 100    male  25\n2 101  female  33\n3 102    Male  27\n4 103    <NA>  40\n5 104     man  44\n6 100    male  25\n7 105 neither  40\n```\n:::\n:::\n\n\nSelect variables `Id` though `Age` as a vector containing the variable names passed as strings and using the `:` operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  select(., c(\"Id\":\"Age\")) # select from here to there\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age\n1 100    male  25\n2 101  female  33\n3 102    Male  27\n4 103    <NA>  40\n5 104     man  44\n6 100    male  25\n7 105 neither  40\n```\n:::\n:::\n\n\nSelect out variables `Id` though `Age` as a vector containing the variable names passed as strings and using the `:` operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  select(., -c(\"Id\":\"Age\"))   # select out from here to there\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Renting\n1     yes\n2    <NA>\n3     yes\n4    <NA>\n5      no\n6     yes\n7     yes\n```\n:::\n:::\n\n\nYou can also use the `!` operator to select *NOT* these variables (therefore, all others)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  select(., !c(\"Id\":\"Age\"))   # select out from here to there\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Renting\n1     yes\n2    <NA>\n3     yes\n4    <NA>\n5      no\n6     yes\n7     yes\n```\n:::\n:::\n\n\n\n## *Selecting and Selecting Out Variables Characters in Their Names*\n\n- `select(., starts_with(\"characters\"))`\n- `select(., ends_with(\"characters\"))`\n- `select(., contains('e'))`\n\nSelect variables which start with character \"i\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% select(., starts_with('i'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id\n1 100\n2 101\n3 102\n4 103\n5 104\n6 100\n7 105\n```\n:::\n:::\n\n\nSelect variables which DO NOT start with character \"s\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% select(., -starts_with('s'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id Age Renting\n1 100  25     yes\n2 101  33    <NA>\n3 102  27     yes\n4 103  40    <NA>\n5 104  44      no\n6 100  25     yes\n7 105  40     yes\n```\n:::\n:::\n\n\nSelect variables which end with character \"e\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% select(., ends_with('e'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Age\n1  25\n2  33\n3  27\n4  40\n5  44\n6  25\n7  40\n```\n:::\n:::\n\n\nSelect variables which end with character \"e\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% select(., -ends_with('e'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Renting\n1 100    male     yes\n2 101  female    <NA>\n3 102    Male     yes\n4 103    <NA>    <NA>\n5 104     man      no\n6 100    male     yes\n7 105 neither     yes\n```\n:::\n:::\n\n\nSelect variables which contain character \"g\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% select(., contains('g'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Age Renting\n1  25     yes\n2  33    <NA>\n3  27     yes\n4  40    <NA>\n5  44      no\n6  25     yes\n7  40     yes\n```\n:::\n:::\n\n\nSelect variables which DO NOT contain character \"g\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% select(., -contains('g'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex\n1 100    male\n2 101  female\n3 102    Male\n4 103    <NA>\n5 104     man\n6 100    male\n7 105 neither\n```\n:::\n:::\n\n\n\nSelect variables containing a regular expression, use `matches()`:\n\n`.*` will grab all names because it means any character and any number of times\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% select(., matches(\".*\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 100    male  25     yes\n2 101  female  33    <NA>\n3 102    Male  27     yes\n4 103    <NA>  40    <NA>\n5 104     man  44      no\n6 100    male  25     yes\n7 105 neither  40     yes\n```\n:::\n:::\n\n\n`\\\\d` will grab all variables containing a digit:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% \n  mutate(., \n         var_1    = 1,\n         var_11   = 1,\n         var_3    = 1,\n         var1_var = 1\n         ) %>%\n  select(., matches(\"\\\\d\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  var_1 var_11 var_3 var1_var\n1     1      1     1        1\n2     1      1     1        1\n3     1      1     1        1\n4     1      1     1        1\n5     1      1     1        1\n6     1      1     1        1\n7     1      1     1        1\n```\n:::\n:::\n\n\n`v.*\\\\d` will grab all variables that start with v and then contain any characters which are followed by a digit:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% \n    mutate(., \n         var_1    = 1,\n         var_11   = 1,\n         var_3    = 1,\n         var1_var = 1\n         ) %>%\n  select(., matches(\"v.*\\\\d\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  var_1 var_11 var_3 var1_var\n1     1      1     1        1\n2     1      1     1        1\n3     1      1     1        1\n4     1      1     1        1\n5     1      1     1        1\n6     1      1     1        1\n7     1      1     1        1\n```\n:::\n:::\n\n\n`\\\\d$` will grab all variables ending in a digit (`$` means end):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% \n    mutate(., \n         var_1    = 1,\n         var_11   = 1,\n         var_3    = 1,\n         var1_var = 1\n         ) %>%\n  select(., matches(\"\\\\d$\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  var_1 var_11 var_3\n1     1      1     1\n2     1      1     1\n3     1      1     1\n4     1      1     1\n5     1      1     1\n6     1      1     1\n7     1      1     1\n```\n:::\n:::\n\n\nYou can also negate all regular expression matches if you want to exclude:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n      mutate(., \n         var_1    = 1,\n         var_11   = 1,\n         var_3    = 1,\n         var1_var = 1\n         ) %>%\n  select(., -matches(\"\\\\d$\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting var1_var\n1 100    male  25     yes        1\n2 101  female  33    <NA>        1\n3 102    Male  27     yes        1\n4 103    <NA>  40    <NA>        1\n5 104     man  44      no        1\n6 100    male  25     yes        1\n7 105 neither  40     yes        1\n```\n:::\n:::\n\n\n\nNote: The functions will return lowercase and uppercase variable name matches because the default behavior is `ignore.case = TRUE`. Set to `FALSE` if you want to perform precise surgery on the variables.  \n\n\n## *Selecting and Selecting Out Variables by Type*\n\nSelect variables that are numeric:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% select(., where(is.numeric))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id Age\n1 100  25\n2 101  33\n3 102  27\n4 103  40\n5 104  44\n6 100  25\n7 105  40\n```\n:::\n:::\n\n\nSelect variables that are NOT numeric:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% select(., -where(is.numeric))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Sex Renting\n1    male     yes\n2  female    <NA>\n3    Male     yes\n4    <NA>    <NA>\n5     man      no\n6    male     yes\n7 neither     yes\n```\n:::\n:::\n\n\nSelect variables that are character:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% select(., where(is.character))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Sex Renting\n1    male     yes\n2  female    <NA>\n3    Male     yes\n4    <NA>    <NA>\n5     man      no\n6    male     yes\n7 neither     yes\n```\n:::\n:::\n\n\nSelect variables that are NOT character:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% select(., -where(is.character))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id Age\n1 100  25\n2 101  33\n3 102  27\n4 103  40\n5 104  44\n6 100  25\n7 105  40\n```\n:::\n:::\n\n\nSelect variables that are logical (`TRUE` to `FALSE`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% select(., where(is.logical))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndata frame with 0 columns and 7 rows\n```\n:::\n:::\n\n\nSelect variables that are NOT logical (`TRUE` to `FALSE`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% select(., -where(is.logical))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 100    male  25     yes\n2 101  female  33    <NA>\n3 102    Male  27     yes\n4 103    <NA>  40    <NA>\n5 104     man  44      no\n6 100    male  25     yes\n7 105 neither  40     yes\n```\n:::\n:::\n\n\n\n# **Cleaning Data**\n\nData files are messy and as a result require cleaning. You will have missing rows, incorrect variable names, files with columns named the same, `NA`s, strings for numbers, duplicate rows of data, people who completed a survey twice, and all sorts of unimaginable and unbelievable data problems. So cleaning is important. \n\nWhereas `select()` is used for columns, `filter()` operates on rows. Data frame manipulation may involve keeping only certain rows for data, for example, male or female respondents, male respondents, those who do not contain missing values (e.g., `NA`s) for a specific column variable, who are of a certain age (or born in in certain year), who are above (or below) some acceptable criterion, etc. \n\nWhen a column variable has more than one value (e.g., check using `unique()` to determine the unique elements contained), you may wish to filter on some but not others. \n\nYou may even need to filter rows in a data frame that are distinct (e.g., not duplicate responses). This is often a good first step in order to determine the size of the usable data set. `dplyr::distinct()` makes de-duplicating easy as this function will return only distinct rows.\n\n\n## *Removing duplicate rows using `distinct()`*\n\n- `dplyr::distinct()`: remove duplicate rows\n- `dplyr::distinct(., column)`: remove duplicate rows by column\n- `na.omit()`: remove any row with NAâ€™s (missing values)\n\nLet's use the simple `DAT` data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT # or with %>% print() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 100    male  25     yes\n2 101  female  33    <NA>\n3 102    Male  27     yes\n4 103    <NA>  40    <NA>\n5 104     man  44      no\n6 100    male  25     yes\n7 105 neither  40     yes\n```\n:::\n:::\n\n\nNotice that rows 1 and 6 are the same person (e.g., Id) and have exactly the same data for all variables. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT[1,] == DAT[6,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Id  Sex  Age Renting\n1 TRUE TRUE TRUE    TRUE\n```\n:::\n:::\n\n\nGreat that the rows are consistent but you don't want their data twice. So let's just remove any rows that are identical.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  distinct(.) #%>%    # Remove exact duplicates\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 100    male  25     yes\n2 101  female  33    <NA>\n3 102    Male  27     yes\n4 103    <NA>  40    <NA>\n5 104     man  44      no\n6 105 neither  40     yes\n```\n:::\n:::\n\n\nIf you know each row is unique based on a variable in the data frame, you can also use `distinct()` to remove duplicates for a specific variable. Make sure that this variable specification is actually one that you would not want duplicates of.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%             \n  distinct(., Id) # %>% view_html(.) # Remove duplicates by variable; passes unique values for data frame\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id\n1 100\n2 101\n3 102\n4 103\n5 104\n6 105\n```\n:::\n:::\n\n\nBut this function simply returns the unique values in `Id`. To retain the variables, set `.keep_all = T`. If you want to remove duplicates and assign the cleaned data frame to an object, you would likely want to keep all of your variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%             \n  distinct(., Id, .keep_all = T) #%>% view_html(.)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 100    male  25     yes\n2 101  female  33    <NA>\n3 102    Male  27     yes\n4 103    <NA>  40    <NA>\n5 104     man  44      no\n6 105 neither  40     yes\n```\n:::\n:::\n\n\nNotice, however, this only removed the last instance or `Id == 100`. Which row to include is a judgment call. The first, the last, neither, the average? Is there a correct answer? \n\n\n# **Filtering using {dplyr} and Understanding Filtering Operators**\n\nFiltering cases using the `dplyr::filter()` verbs works by removing rows that do not match a specific criterion and then by returning the data frame that omits the mismatched condition. \n\nSome useful filtering operators and functions include: `==`, `>`, `>=`, `&`, `|`, `!`, `xor()`, `c()`, `is.na()`, `between()`, `near()`. \n\nRow/Observations/Cases can be filtered to \"include\" only certain matched conditions or can be filtered to \"exclude\" by negating those matched conditions. If the column variable `Sex` is in the data frame and cases are `'male'`, `'men'`, `'female'`, `'women'`, `'neither'`, `NA`, etc., you can specify the column `Sex` variable and then the row matching condition(s). \n\nThe first argument in `dplyr::filter()` is a data frame, and the function all `dplyr::filter(DAT, Sex == 'female')` will filter the data frame named `DAT` to include rows for which the `sex` column equals `'female'`. In other words, `TRUE` rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::filter(DAT, Sex == 'female')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id    Sex Age Renting\n1 101 female  33    <NA>\n```\n:::\n:::\n\n\nSimilarly, the function call `dplyr::filter(., Sex == 'male')` can be read \"filter the data frame to include rows for which the value of `Sex == 'male'` is `TRUE`\". \n\nMore flexibly, however, you could specify a vector containing acceptable strings using `c()`. `dplyr::filter(., Sex %in% c('male'))` filters the rows to include only those for which the value for `sex` is in the string vector which includes a single string,`'male'` whereas `dplyr::filter(., Sex %in% c('male', 'Man'))` filters the rows to include only those for which the value for `Sex` is in the string vector which includes `'male'` and `'Man'`. Cases containing `'Male'`, `'Men'` (R is a case-sensitive language), or `'female'`, for example, will not be included in the returned data frame because they do not match values in the string vector. \n\n\n# **Piping Multiple Filter Function Calls**\n\nIn many cases, data filtering will involve different conditions for different column variables, so specifying them separately as separate lines of code is most appropriate. \n\nWhen passing a data frame using `%>%` from **{magrittr}**, the first argument for the data frame can be specified using a `.` because the function inherits the data frame manipulated. However, **{dplyr}** also understand this so the `.` can also be omitted for convenience; this is the general practice you will see in forums like [stackoverflow.com](stackoverflow.com). Example to follow.\n\n\n# **Filtering Cases by Character Names/String Values **\n\n## *Filter Cases using `==`*\n\nFilter rows for which the `Sex` variable is equal to the string `'female'`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  dplyr::filter(., Sex == 'female')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id    Sex Age Renting\n1 101 female  33    <NA>\n```\n:::\n:::\n\n\nFilter rows for which the `Sex` variable is not equal to the string `'female'`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  dplyr::filter(., Sex != 'female')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 100    male  25     yes\n2 102    Male  27     yes\n3 104     man  44      no\n4 100    male  25     yes\n5 105 neither  40     yes\n```\n:::\n:::\n\n\n\nFilter rows for which the `Sex` variable is equal to the string `'female'` **AND** `Age` is greater than the numeric 27:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  dplyr::filter(., Sex == 'female' & Age > 27) # this \"AND\" that\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id    Sex Age Renting\n1 101 female  33    <NA>\n```\n:::\n:::\n\n\nFilter rows for which the `Sex` variable is equal to the string `'female'` **OR** `Age` is greater than the numeric 27:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  dplyr::filter(., Sex == 'female' | Age > 27) # this \"OR\" that\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 101  female  33    <NA>\n2 103    <NA>  40    <NA>\n3 104     man  44      no\n4 105 neither  40     yes\n```\n:::\n:::\n\n\nA cleaner method involves separate lines of code. Although cleaner, this will not allow the \"OR\" option because the data frame that is returned from the first `filter()` is passed to the second `filter()` and all cases other than `\"female\"` have already been removed from the data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  dplyr::filter(., Sex == 'female') %>%   # keep female (and add another pipe)\n  dplyr::filter(., Age >= 27)             # keep only those equal to or older than 27\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id    Sex Age Renting\n1 101 female  33    <NA>\n```\n:::\n:::\n\n\n\n# **Filtering Cases by Value**\n\n## *Filter by `<` and `>` or `<=` or `>=`...*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% dplyr::filter(., Age < 40)  # keep those less than \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id    Sex Age Renting\n1 100   male  25     yes\n2 101 female  33    <NA>\n3 102   Male  27     yes\n4 100   male  25     yes\n```\n:::\n\n```{.r .cell-code}\nDAT %>% dplyr::filter(., Age > 40)  # keep older than\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id Sex Age Renting\n1 104 man  44      no\n```\n:::\n\n```{.r .cell-code}\nDAT %>% dplyr::filter(., Age >= 40)  # keep equal to or older than\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 103    <NA>  40    <NA>\n2 104     man  44      no\n3 105 neither  40     yes\n```\n:::\n:::\n\n\n\n## **Filter Cases by Conditional X *or* Y Using `|` Operator...**\n\nUsing the \"OR\" operator, `|`, cases can be included if \"this\" OR \"that\" condition.\n\nFilter numbers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  dplyr::filter(., Age == 25 | Age == 40)    # filter out numeric values IN a range\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 100    male  25     yes\n2 103    <NA>  40    <NA>\n3 100    male  25     yes\n4 105 neither  40     yes\n```\n:::\n:::\n\n\n\nFilter characters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  dplyr::filter(., Sex == 'male' | Sex == 'female')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id    Sex Age Renting\n1 100   male  25     yes\n2 101 female  33    <NA>\n3 100   male  25     yes\n```\n:::\n:::\n\n\nAlthough `dplyr::filter(sex %in% c('male', 'female'))` would be easier.\n\n\nFilter rows of variables of both types:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  dplyr::filter(., Sex == 'male' | Age == 27)  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id  Sex Age Renting\n1 100 male  25     yes\n2 102 Male  27     yes\n3 100 male  25     yes\n```\n:::\n:::\n\n\n\n## **Filter Cases Between Values with `between()`**\n\nBetween ages 25 and 33:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  dplyr::filter(., between(Age, 27, 33))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id    Sex Age Renting\n1 101 female  33    <NA>\n2 102   Male  27     yes\n```\n:::\n:::\n\n\n\n## *Filter by range using the `%in%` operator (this is IN meaning in)*\n\nThough less flexible than using `between()`, `%in%` may be easier to remember:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  dplyr::filter(., Age %in% 20:43)    # filter out numeric values IN a range\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 100    male  25     yes\n2 101  female  33    <NA>\n3 102    Male  27     yes\n4 103    <NA>  40    <NA>\n5 100    male  25     yes\n6 105 neither  40     yes\n```\n:::\n:::\n\n\nOne's age is in the range from 20 through 43.\n\n\nIf a vector object is already defined (e.g., `my_levels = c('male', 'female')`), you can use that for filtering also. Such approaches are useful when data manipulation involves reusing a reference as it simplifies coding and reduces errors because the specification is defined only once.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_levels = c('male', 'female')\n\nDAT %>%\n  dplyr::filter(., Sex %in% my_levels)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id    Sex Age Renting\n1 100   male  25     yes\n2 101 female  33    <NA>\n3 100   male  25     yes\n```\n:::\n:::\n\n\n## *Filter by exclusion*\n\nWhen inclusion of variables is inappropriate, exclusion of them may be useful. The `!` operator means \"NOT\" in `R` so you can use that to accomplish the opposite of the statement. For example, `dplyr::filter(., !sex %in% c('male', NA))` will \"filter the data frame to include rows in the `sex` column for which the value is NOT in the vector\".\n\nExclude rows in the `Sex` variable that are `NA` or `'male'`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  dplyr::filter(., !Sex %in% c('male', NA))  # keep only if NOT in vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 101  female  33    <NA>\n2 102    Male  27     yes\n3 104     man  44      no\n4 105 neither  40     yes\n```\n:::\n:::\n\n\nExclude rows in the `Sex` variable that are `Men` or `'male'`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  dplyr::filter(., !Sex %in% c('male', 'Men'))  # keep only if NOT in vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 101  female  33    <NA>\n2 102    Male  27     yes\n3 103    <NA>  40    <NA>\n4 104     man  44      no\n5 105 neither  40     yes\n```\n:::\n:::\n\n\n\n## *Filter by conditional X and Y using `&` operator...*\n\nBy range:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  dplyr::filter(., Id >= 102 & Age <= 43)    \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 102    Male  27     yes\n2 103    <NA>  40    <NA>\n3 105 neither  40     yes\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  dplyr::filter(., Age >= 20 & Age <= 43)    \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 100    male  25     yes\n2 101  female  33    <NA>\n3 102    Male  27     yes\n4 103    <NA>  40    <NA>\n5 100    male  25     yes\n6 105 neither  40     yes\n```\n:::\n:::\n\n\nNote: Age 20:43 won't work. Can you figure out why?\n\n\n\n# **Filter Cases Containing Characters Using `stringr::str_detect()` and `%in%`:**\n\nIf you want to filter cases that contain certain characters, unfortunately, you cannot use `contains()` as you would for variable names. For matching characters in levels of variables, you'll need something like `stringr::str_detect()` or `grepl()`. \n\n- `stringr::str_detect()`: returns matching conditions\n\nThe example below uses `str_detect()` to detect the presence of a character match and returns a logic vector with `TRUE`s for matching cases. When paired with `filter()`, the data frame is filtered by to contains cases that match the pattern for the variable.\n\nExample: `stringr::str_detect(my_variable, \"pattern\")`: \n\nLet's look for levels of `Sex` for which `\"ma\"` is detected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% dplyr::filter(., stringr::str_detect(Sex, \"ma\")) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id    Sex Age Renting\n1 100   male  25     yes\n2 101 female  33    <NA>\n3 104    man  44      no\n4 100   male  25     yes\n```\n:::\n:::\n\n\nBut the case for which `Sex = Male` is now missing. This is because `stringr::str_detect()` is a case-sensitive pattern match. \n\nYou can fix this is a couple ways:\n\n1) make the cases in `Sex` all lower case to `mutate()` the fix or\n2) to wrap `Sex` in `tolower()` to make cases lowercase. \n\nThe first option might be better if you want to fix the problem in the data frame. \n\nOther casing functions are:\n\n- `tolower()`: returns lower case of string\n- `toupper()`: returns upper case of string\n- `tools::toTitleCase()`: returns Title Case (capitalize first letter of string) \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  filter(., stringr::str_detect(tolower(Sex), \"ma\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id    Sex Age Renting\n1 100   male  25     yes\n2 101 female  33    <NA>\n3 102   Male  27     yes\n4 104    man  44      no\n5 100   male  25     yes\n```\n:::\n:::\n\n\nFor some, reading this code may be difficult. In order to understand the code, you need to read it inside out like slices of an onion. First understand the first function as the returned value is passed to the next function and so forth. \n\nFor example, elements of the `Sex` vector are converted to lower case and returned using `tolower()`. We can demonstrate this using only the vector from the data frame using the `$` operator, `DAT$Sex`.\n\nThe initial vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT$Sex\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"male\"    \"female\"  \"Male\"    NA        \"man\"     \"male\"    \"neither\"\n```\n:::\n:::\n\n\nTo lowercase:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntolower(DAT$Sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"male\"    \"female\"  \"male\"    NA        \"man\"     \"male\"    \"neither\"\n```\n:::\n:::\n\n\nNext, `stringr::str_detect()` will return a vector of `TRUE` or `FALSE` for all element positions of `DAT$Sex` for which the (now lowercase) string matches `\"ma\"`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringr::str_detect(tolower(DAT$Sex), \"ma\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE  TRUE    NA  TRUE  TRUE FALSE\n```\n:::\n:::\n\n\nAnother approach would be to perform the steps in pieces by first mutating the data frame so that elements in the `Sex` vector are converted to lowercase and then pipe that mutated data from to `filter()`.  \n\nBriefly, we will introduce `dplyr::mutate()` to accomplish this goal. `mutate()` is used to add, update, etc. variables in a data frame or tibble.\n\nMutate `Sex` using `mutate()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  mutate(., Sex = tolower(Sex))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 100    male  25     yes\n2 101  female  33    <NA>\n3 102    male  27     yes\n4 103    <NA>  40    <NA>\n5 104     man  44      no\n6 100    male  25     yes\n7 105 neither  40     yes\n```\n:::\n:::\n\n\nNow mutate and pipe that mutated data frame using `%>%` (from **{margittr}**) or `|>` (`base R` version 4.1+) to `filter()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  mutate(., Sex = tolower(Sex)) %>%\n  filter(., stringr::str_detect(Sex, \"ma\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id    Sex Age Renting\n1 100   male  25     yes\n2 101 female  33    <NA>\n3 102   male  27     yes\n4 104    man  44      no\n5 100   male  25     yes\n```\n:::\n:::\n\n\n\nPairing this piping approach with `toTitleCase()` may be better as only the first letter will be capitalized and you are looking for \"Ma\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  mutate(., Sex = tools::toTitleCase(Sex)) %>%\n  filter(., stringr::str_detect(Sex, \"Ma\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id  Sex Age Renting\n1 100 Male  25     yes\n2 102 Male  27     yes\n3 104  Man  44      no\n4 100 Male  25     yes\n```\n:::\n:::\n\n\nBut notice the `male` and `man` issue is still a problem. \n\nSo what are the unique elements in `DAT$Sex`? Your friend here is `unique()`. And maybe you are too.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(DAT$Sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"male\"    \"female\"  \"Male\"    NA        \"man\"     \"neither\"\n```\n:::\n:::\n\n\nYou can hard code a fix using `%in%` and `case_when()`. `case_when()` is **{dplyr}**'s solution for multiple-case conditional.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  mutate(., \n         Sex = tolower(Sex), # convert to lowercase first\n         Sex = case_when(    # then recode cases when matched\n           Sex %in% c(\"male\", \"man\") ~ \"Male\",\n           Sex %in% c(\"female\", \"woman\") ~ \"Female\"\n         )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id    Sex Age Renting\n1 100   Male  25     yes\n2 101 Female  33    <NA>\n3 102   Male  27     yes\n4 103   <NA>  40    <NA>\n5 104   Male  44      no\n6 100   Male  25     yes\n7 105   <NA>  40     yes\n```\n:::\n:::\n\n\nFor a more flexible fix, you can use `str_detect()`:\n\nBUT beware that the order of operations matters with this approach. Because the string \"female\" contains characters \"ma\", you could accidentally recode all \"female\" cases to \"male\" if you perform the `case_when()` conversion on \"male\" first. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  mutate(., \n         Sex = tolower(Sex),   # convert first\n         Sex = case_when(      # then recode\n           stringr::str_detect(Sex, \"fe\") ~ \"Female\",\n           stringr::str_detect(Sex, \"ma\") ~ \"Male\",\n         ))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id    Sex Age Renting\n1 100   Male  25     yes\n2 101 Female  33    <NA>\n3 102   Male  27     yes\n4 103   <NA>  40    <NA>\n5 104   Male  44      no\n6 100   Male  25     yes\n7 105   <NA>  40     yes\n```\n:::\n:::\n\n\nNote that conditions in not declared in `case_when()` will be recoded as `NA`, which is what happens for `\"neither\"`. Make sure to include all ways you wish you recode cases.\n\n\n\n# **Filtering Missing Data (`NAs`)**\n\n`is.na()` will return a logical vector for which `TRUE` represents there are missing values.\n\nTry on the entire data frame...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(DAT)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Id   Sex   Age Renting\n[1,] FALSE FALSE FALSE   FALSE\n[2,] FALSE FALSE FALSE    TRUE\n[3,] FALSE FALSE FALSE   FALSE\n[4,] FALSE  TRUE FALSE    TRUE\n[5,] FALSE FALSE FALSE   FALSE\n[6,] FALSE FALSE FALSE   FALSE\n[7,] FALSE FALSE FALSE   FALSE\n```\n:::\n:::\n\n\nYou can see that some columns contain cases/rows with `TRUE` indicating the cell contains `NA`.\n\nThe negation operator, `!`, will be used to illustrate some filtering approaches. Because `filter()` will filter out `FALSE` cases and retain `TRUE` ones, so you may sometimes need to negate a function so that you keep the rows you want to keep.  \n\n- `na.omit()`: removes rows with NAs\n- `filter(., is.na(column_name))`: keep rows with NA in specific variable\n- `filter(., !is.na(column_name))`: remove rows with NA in specific variable\n- `filter(., complete.cases(.))`: remove rows with NAs\n\n\n## *Filter using `na.omit()`:*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  na.omit(.) #%>%     # omit any rows with NAs \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 100    male  25     yes\n3 102    Male  27     yes\n5 104     man  44      no\n6 100    male  25     yes\n7 105 neither  40     yes\n```\n:::\n:::\n\n\n\n## *Filter using `is.na()` and `!is.na()`:*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  filter(., is.na(Sex))       # keep NAs by variable\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id  Sex Age Renting\n1 103 <NA>  40    <NA>\n```\n:::\n:::\n\n\nBut your goal may likely be to keep everything that is not `NA`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  filter(., !is.na(Sex))      # remove NAs by variable\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 100    male  25     yes\n2 101  female  33    <NA>\n3 102    Male  27     yes\n4 104     man  44      no\n5 100    male  25     yes\n6 105 neither  40     yes\n```\n:::\n:::\n\n\nAnd filter step-by-step for each variable using `%>%` and separate function calls: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  filter(., !is.na(Sex)) %>%      \n  filter(., !is.na(Renting))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 100    male  25     yes\n2 102    Male  27     yes\n3 104     man  44      no\n4 100    male  25     yes\n5 105 neither  40     yes\n```\n:::\n:::\n\n\nSo why use separate lines of code if you can use `&` all in one line? One reason is that separate function calls written as separate lines of code make code inclusion/exclusion extremely easy.\n\nComment out what you don't want using `#`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  #filter(., !is.na(Sex)) %>%      \n  filter(., !is.na(Renting))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 100    male  25     yes\n2 102    Male  27     yes\n3 104     man  44      no\n4 100    male  25     yes\n5 105 neither  40     yes\n```\n:::\n:::\n\n\n\n## *Filter using `complete.cases()`:*\n\nThe `complete.cases()` function returns a logical vector for which `TRUE` reflects the row has complete information and no missing cases. Using `complete.cases()` along with `filter()`, you would retain all rows `TRUE` rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  dplyr::filter(., complete.cases(.))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Id     Sex Age Renting\n1 100    male  25     yes\n2 102    Male  27     yes\n3 104     man  44      no\n4 100    male  25     yes\n5 105 neither  40     yes\n```\n:::\n:::\n\n\n\n# **The Data Manipulation Workflow: Putting It All Together**\n\nOf course, all of these functions can be paired with `select()`, `mutate()`, `filter()`, etc. Here is the data manipulation workflow. \n\n```\ndataframe %>%\n    select(., ...) %>%     # select variables of interest\n    mutate(., ...) %>%     # then create new variables\n    filter(., ...) %>%     # then filter by rows\n    group_by(., ...) %>%   # then group for subsetting\n    summarize(., ...)      # then summarize\n```\n\n# **Session Information**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 11 x64 (build 22621)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/Los_Angeles\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] stringr_1.5.0  dplyr_1.1.2    magrittr_2.0.3\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.3       cli_3.6.1         knitr_1.43        rlang_1.1.1      \n [5] xfun_0.40         stringi_1.7.12    generics_0.1.3    jsonlite_1.8.7   \n [9] glue_1.6.2        rprojroot_2.0.3   htmltools_0.5.6   fansi_1.0.4      \n[13] rmarkdown_2.24    evaluate_0.21     tibble_3.2.1      fastmap_1.1.1    \n[17] yaml_2.3.7        lifecycle_1.0.3   compiler_4.3.1    htmlwidgets_1.6.2\n[21] pkgconfig_2.0.3   here_1.0.1        rstudioapi_0.15.0 digest_0.6.33    \n[25] R6_2.5.1          tidyselect_1.2.0  utf8_1.2.3        pillar_1.9.0     \n[29] withr_2.5.0       tools_4.3.1      \n```\n:::\n:::\n",
    "supporting": [
      "04_data_frame_manipulation_and_wrangling_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}