{
  "hash": "d31230fd621635a253a4d29f269830ba",
  "result": {
    "markdown": "---\ntitle: \"**Data subsets and summaries**\"\nauthor: \"Gabriel I. Cook\"\n#date: \"2023-12-18\"\ndate: \"18 December, 2023\"\n\nexecute:\n  #enabled: false\n  freeze: auto\n---\n\n\n::: callout-important\n## Under construction. \n\nThis page is a work in progress and may contain areas that need more detail or that required syntactical, grammatical, and typographical changes. If you find some part requiring some editing, please let me know so I can fix it for you.\n\n:::\n\n\n\n\n\n# **Overview**\n\nThis module demonstrates how to use **{dplyr}** to subset data, mutate variables, and summarize variables in data frames. Many data summaries involve creating group-level statistics so we will also cover grouping across variables. **{lubridate}** will be used to handle time vectors.\n\n\n# **To Do**\n\n## **Readings**\n\n\n## **Task**\n\n\n## **Libraries** \n\n- **{here}**: 1.0.1: for path management\n- **{dplyr}** 1.1.2: for selecting, filtering, and mutating\n- **{magrittr}** 2.0.3: for code clarity and piping data frame objects\n- **{lubridate}** 1.9.2: for handling date and time vectors\n\n\n## **External Functions**\n\nProvided in class:\n\n`view_html()`: for viewing data frames in html format, from `/r/my_functions.R` \n\nYou can use this in your own workspace but I am having a challenge rendering this of the website, so I'll default to `print()` on occasion.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(here::here(\"r\", \"my_functions.R\"))\n```\n:::\n\n\n## **Libraries**\n\nWe will work with a few different libraries for data manipulation. Let's load them into our work space using `library()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magrittr)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(stringr)\nlibrary(lubridate)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'lubridate'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n```\n:::\n:::\n\n\n\n# **Loading and Looking at Data**\n\nIn order to perform any data summary, you need data. We will use the file name `\"cms-top-all-time-2023-swim.xlsx\"` that is located at a URL. We could just access the file from the full URL path but we will later want to same a *cleaned* version of the file for later use. Modifying the file name will be easier than hard coding the path in both places. Thus, we will use `paste()` to concatenate the file name and the URL location while also passing the `sep = \"\"` argument to make sure there is no space (an empty string) between the two strings. By default, `paste()` uses `sep = \" \"`, which you can see contains a string with a space. We will then pass that concatenated string to `openxlsx::read.xlsx()` and assign the returned data frame to an object named `DAT`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_name <- \"cms-top-all-time-2023-swim.xlsx\"\nbase_url <- \"https://github.com/slicesofdata/dataviz23/raw/main/data/\"\n```\n:::\n\n\nLook to make sure there are not any odd spacing. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(base_url, file_name, sep = \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"https://github.com/slicesofdata/dataviz23/raw/main/data/cms-top-all-time-2023-swim.xlsx\"\n```\n:::\n:::\n\n\n\nWe will  pass this string to the `xlxsFile` argument and also pass `sheet = \"swim\"` so the swim worksheet is read from the file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT <- openxlsx::read.xlsx(\n  xlsxFile = paste(base_url, file_name, sep = \"\"), \n  sheet = \"swim\"\n  )\n```\n:::\n\n\nView its contents:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(DAT) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   time             name year   event   team\n1 23.29 Jocelyn Crawford 2019 50 FREE Athena\n2 23.31    Ava Sealander 2022 50 FREE Athena\n3 23.49        Kelly Ngo 2016 50 FREE Athena\n4 23.71        Helen Liu 2014 50 FREE Athena\n5 23.76      Michele Kee 2014 50 FREE Athena\n6 23.77 Natalia Orbach-M 2020 50 FREE Athena\n```\n:::\n\n```{.r .cell-code}\n#view_html(DAT)\n```\n:::\n\n\nWe have several variables: time, name, year, event, team. Some appear to be numeric and some are characters. Passing the data frame to `dplyr::glimpse()` will provide more detail (see also `str()`). \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::glimpse(DAT)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 440\nColumns: 5\n$ time  <chr> \"23.29\", \"23.31\", \"23.49\", \"23.71\", \"23.76\", \"23.77\", \"23.77\", \"…\n$ name  <chr> \"Jocelyn Crawford\", \"Ava Sealander\", \"Kelly Ngo\", \"Helen Liu\", \"…\n$ year  <chr> \"2019\", \"2022\", \"2016\", \"2014\", \"2014\", \"2020\", \"2020\", \"2010\", …\n$ event <chr> \"50 FREE\", \"50 FREE\", \"50 FREE\", \"50 FREE\", \"50 FREE\", \"50 FREE\"…\n$ team  <chr> \"Athena\", \"Athena\", \"Athena\", \"Athena\", \"Athena\", \"Athena\", \"Ath…\n```\n:::\n\n```{.r .cell-code}\n# or DAT %>% dplyr::glimpse()\n```\n:::\n\n\nHmm, looks like there are `<chr>` and `<dbl>` variables and some numbers are in quotes. Objects in quotes are strings. So we need to clean up the file before we can even get a summary. Other than looking at the structure of data frame using `glimpse()` or `str()`, you can examine vectors individually. \n\nWhen vectors are in data frames, you can reference them using the `$` notation: `my_dataframe$my_variable`. Passing this to `is.numeric()` will also tell you whether the vector is numeric by returning either `TRUE` or `FALSE`.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(DAT$time)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nOK, so this variable is definitely not numeric. Looking at the file, we need to convert at least one variable that should be numbers from character to numeric. \n\n\n# **Modifying a Data Frame or Tibble Using {dplyr}**\n\nUse `dplyr::mutate()` to create, modify, and delete column variables. At every least, you will need to pass a data frame as the first argument, `.data` and then a name-value pair as the second argument. There are other arguments that are experimental which will not be the focus of this module. \n\n```\nmutate(\n  .data,\n  ...,\n  .by = NULL,\n  .keep = c(\"all\", \"used\", \"unused\", \"none\"),\n  .before = NULL,\n  .after = NULL\n)\n```\n\nWe will use `mutate()` in conjunction with **{magrittr}**'s `%>%` for code piping.\n\n\n## **Creating a new variable**\n\nWe will pass the data frame into `mutate()` and then specify a name-value variable pair. When using `%>%`, the data frame piped into the function will be represented as `.`. This `.` is not needed but serves as a good reminder that the data frame that is passed into `mutate()` is from the previous line of code. In order to keep the print out manageable, we will also use the `slice()` function.\n\n```\nmutate(data_frame, \n    new_variable_name = variable\n    )\n```\n\nCreate new variables that are set to a constant number or string:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  slice(., 1:5) %>%   # rows 1 through 5\n  mutate(., newvar1 = 9999) %>%\n  mutate(., newvar2 = \"Student\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   time             name year   event   team newvar1 newvar2\n1 23.29 Jocelyn Crawford 2019 50 FREE Athena    9999 Student\n2 23.31    Ava Sealander 2022 50 FREE Athena    9999 Student\n3 23.49        Kelly Ngo 2016 50 FREE Athena    9999 Student\n4 23.71        Helen Liu 2014 50 FREE Athena    9999 Student\n5 23.76      Michele Kee 2014 50 FREE Athena    9999 Student\n```\n:::\n:::\n\n\nYou can see that each row in the data frame will take on the paired value. \n\n\n## **Modifying a new variable**\n\nNew variables are modified using the same name-value pairing approach. When you modify a variable, you are taking an existing variable to setting it to another value. \n\n### *Set an existing variable equal to a constant*\n\nJust use an existing variable name (left of `=` in name-value pair).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  slice(., 1:5) %>%   # rows 1 through 5\n  mutate(., time = 1) %>%\n  mutate(., name = \"0\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  time name year   event   team\n1    1    0 2019 50 FREE Athena\n2    1    0 2022 50 FREE Athena\n3    1    0 2016 50 FREE Athena\n4    1    0 2014 50 FREE Athena\n5    1    0 2014 50 FREE Athena\n```\n:::\n:::\n\n\nOK, that's not very helpful. We just replaced our existing variables with nothing useful. You can see that name is still a `<chr>` type.\n\n\n### *Set an existing variable equal to another value*\n\nAs long as **{dplyr}** can result the character elements of the vector, `as.numeric()` will convert the character strings to numbers. For example: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(c(\"1\", \"3.2\", \"6.99\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.00 3.20 6.99\n```\n:::\n:::\n\n\nWe can illustrate in a data frame by creating character value that will serve as the constant, and use `as.numeric()` just to illustrate this example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  slice(., 1:5) %>%   # rows 1 through 5\n  mutate(., name = as.numeric(\"0\")) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   time name year   event   team\n1 23.29    0 2019 50 FREE Athena\n2 23.31    0 2022 50 FREE Athena\n3 23.49    0 2016 50 FREE Athena\n4 23.71    0 2014 50 FREE Athena\n5 23.76    0 2014 50 FREE Athena\n```\n:::\n:::\n\n\nAnd now `name` is a `<dbl>`, which is a type of numeric. We can see this by selecting columns from the data frame `where()` the variable `is.numeric()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  slice(., 1:5) %>%   # rows 1 through 5\n  mutate(., name = as.numeric(\"0\")) %>%\n  select(., where(~is.numeric(.)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name\n1    0\n2    0\n3    0\n4    0\n5    0\n```\n:::\n:::\n\n\nBut if we try to convert `time` to numeric this way, you will see that the complex numbers will be converted to `NA`s, or missing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(DAT$time)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 23.29 23.31 23.49 23.71 23.76 23.77 23.77 23.87 23.93 24.02 51.05 51.24\n [13] 51.41 51.56 51.56 51.88 52.05 52.05 52.14 52.17    NA    NA    NA    NA\n [25]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n [37]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n [49]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n [61] 55.66 55.67 55.91 56.11 56.74 56.83 57.18 57.36 57.47 57.56    NA    NA\n [73]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n [85]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n [97]    NA    NA    NA    NA 54.76 54.92 54.93 55.23 55.74 56.04 56.27 56.42\n[109] 56.47 56.56    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n[121]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA 22.69 22.92\n[133] 22.93 22.95 23.27 23.31 23.33 23.38 23.45 23.47 50.65 50.67 50.92 51.19\n[145] 51.27 51.28 51.29 51.37 51.45 51.56    NA    NA    NA    NA    NA    NA\n[157]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n[169]    NA    NA 25.94 26.22 26.28 26.57 26.82 26.90 27.14 27.14 27.16 27.17\n[181] 28.33 28.96 29.05 29.06 29.09 29.09 29.24 29.26 29.46 29.55 24.05 24.28\n[193] 24.58 24.59 24.65 24.85 25.05 25.08 25.24 25.34 54.65 54.81 54.91 55.11\n[205] 55.13 55.25 55.27 55.45 55.62 56.21    NA    NA    NA    NA    NA    NA\n[217]    NA    NA    NA    NA 19.98 20.21 20.22 20.36 20.51 20.65 20.69 20.71\n[229] 20.79 20.82 44.06 44.21 44.73 44.94 45.24 45.31 45.32 45.45 45.50 45.50\n[241]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n[253]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n[265]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n[277]    NA    NA    NA    NA 46.99 47.57 49.32 49.97 50.03 50.29 50.35 50.41\n[289] 50.51 50.59    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n[301] 54.88 55.80 55.92 56.03 56.27 56.35 56.36 56.45 56.49 56.49    NA    NA\n[313]    NA    NA    NA    NA    NA    NA    NA    NA 47.45 47.56 47.80 48.74\n[325] 48.91 49.26 49.31 49.34 49.68 49.74    NA    NA    NA    NA    NA    NA\n[337]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n[349]    NA    NA 19.47 19.63 19.96 20.08 20.10 20.14 20.18 20.22 20.25 20.28\n[361] 43.28 43.69 43.74 44.43 44.57 44.59 44.81 44.81 44.83 44.87    NA    NA\n[373]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n[385]    NA    NA    NA    NA    NA    NA 22.32 22.50 22.84 23.00 23.24 23.45\n[397] 23.72 23.74 23.85 23.87 24.73 24.81 24.88 25.10 25.20 25.47 25.55 25.63\n[409] 26.01 26.05 20.60 21.38 21.48 21.58 21.60 21.81 21.83 22.00 22.06 22.07\n[421] 47.01 47.72 48.39 48.50 48.54 48.82 49.00 49.45 49.52 49.60 54.52 55.15\n[433] 55.21 55.47 55.62 56.04 56.13 56.19 56.35 56.48\n```\n:::\n:::\n\n\nThe problem we have is that the data are not in a clean form. In this data frame, some elements of `time` are composed of numbers, decimals, and colons (e.g., x.xx, xx:xx.xx, etc.). which all make up elements that would be numbers. \n\n\n### **Converting variables that are time related using {lubridate}**\n\n**{lubridate}** is a library for dealing with dates and times. It is also part of the **tidyverse}** ecosystem. \n\nThe `period_to_seconds()` function will convert periods to seconds depending on the period format. We need to pass to it an object that equates to a period of seconds.\n\nFor `time`, the format is: hour minute second (e.g., `hms`). And there is a `hms()` function to handle this. Let's see how it works before modifying the data frame. Load the library if it is not loaded. \n\nWe will pass a single character string and convert it to `hms` with `hms()` and then convert that to seconds using `period_to_seconds()`. Because 60 minutes and 1 hour is the same number of seconds, we should end up with the same values. We can also use `ms()` to convert the format into minutes and seconds and pass to `period_to_seconds()`. Following the examples, we will apply to the vector in the data frame.\n\n```\nlubridate::period_to_seconds(lubridate::ms())\nlubridate::period_to_seconds(lubridate::hms())\n```\n\nSixty minutes and one hour to `hms`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlubridate::hms(\"00:60:00\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"60M 0S\"\n```\n:::\n\n```{.r .cell-code}\nlubridate::hms(\"01:00:00\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1H 0M 0S\"\n```\n:::\n:::\n\n\nOne day to `hms`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhms(\"24:00:00\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"24H 0M 0S\"\n```\n:::\n:::\n\n\n\nSixty minutes and one hour to `hms` to seconds:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlubridate::period_to_seconds(lubridate::hms(\"00:60:00\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3600\n```\n:::\n\n```{.r .cell-code}\nlubridate::period_to_seconds(lubridate::hms(\"01:00:00\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3600\n```\n:::\n:::\n\n\nOK, good. So let's see if we can convert `time`. Because `hms()` is passed into `period_to_seconds()`, we first need to verify that `hms()` can handle it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhms(DAT$time)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in .parse_hms(..., order = \"HMS\", quiet = quiet): Some strings failed\nto parse, or all strings are NAs\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] NA            NA            NA            NA            NA           \n  [6] NA            NA            NA            NA            NA           \n [11] NA            NA            NA            NA            NA           \n [16] NA            NA            NA            NA            NA           \n [21] \"1H 50M 30S\"  \"1H 51M 89S\"  \"1H 52M 40S\"  \"1H 52M 55S\"  \"1H 52M 57S\" \n [26] \"1H 52M 67S\"  \"1H 52M 80S\"  \"1H 52M 83S\"  \"1H 52M 88S\"  \"1H 52M 89S\" \n [31] \"4H 57M 37S\"  \"4H 59M 22S\"  \"4H 59M 78S\"  \"5H 0M 6S\"    \"5H 0M 21S\"  \n [36] \"5H 0M 47S\"   \"5H 1M 17S\"   \"5H 1M 99S\"   \"5H 2M 16S\"   \"5H 2M 23S\"  \n [41] \"10H 14M 33S\" \"10H 15M 40S\" \"10H 22M 59S\" \"10H 22M 84S\" \"10H 24M 14S\"\n [46] \"10H 24M 82S\" \"10H 26M 34S\" \"10H 26M 89S\" \"10H 33M 15S\" \"10H 36M 60S\"\n [51] \"16H 58M 48S\" \"17H 3M 21S\"  \"17H 6M 78S\"  \"17H 9M 9S\"   \"17H 9M 26S\" \n [56] \"17H 12M 18S\" \"17H 12M 46S\" \"17H 13M 58S\" \"17H 21M 98S\" \"17H 24M 49S\"\n [61] NA            NA            NA            NA            NA           \n [66] NA            NA            NA            NA            NA           \n [71] \"1H 59M 91S\"  \"2H 2M 10S\"   \"2H 3M 73S\"   \"2H 3M 85S\"   \"2H 3M 92S\"  \n [76] \"2H 5M 10S\"   \"2H 5M 56S\"   \"2H 5M 71S\"   \"2H 5M 76S\"   \"2H 6M 13S\"  \n [81] \"1H 1M 84S\"   \"1H 3M 28S\"   \"1H 3M 51S\"   \"1H 3M 91S\"   \"1H 4M 16S\"  \n [86] \"1H 4M 19S\"   \"1H 4M 65S\"   \"1H 4M 66S\"   \"1H 4M 77S\"   \"1H 4M 94S\"  \n [91] \"2H 14M 83S\"  \"2H 15M 62S\"  \"2H 18M 99S\"  \"2H 19M 6S\"   \"2H 19M 78S\" \n [96] \"2H 20M 1S\"   \"2H 21M 17S\"  \"2H 21M 77S\"  \"2H 22M 34S\"  \"2H 22M 83S\" \n[101] NA            NA            NA            NA            NA           \n[106] NA            NA            NA            NA            NA           \n[111] \"2H 1M 84S\"   \"2H 2M 58S\"   \"2H 3M 80S\"   \"2H 4M 5S\"    \"2H 4M 42S\"  \n[116] \"2H 4M 81S\"   \"2H 6M 40S\"   \"2H 7M 12S\"   \"2H 7M 33S\"   \"2H 7M 42S\"  \n[121] \"2H 0M 69S\"   \"2H 3M 59S\"   \"2H 3M 79S\"   \"2H 4M 74S\"   \"2H 5M 41S\"  \n[126] \"2H 6M 82S\"   \"2H 7M 12S\"   \"2H 7M 14S\"   \"2H 7M 81S\"   \"2H 7M 94S\"  \n[131] NA            NA            NA            NA            NA           \n[136] NA            NA            NA            NA            NA           \n[141] NA            NA            NA            NA            NA           \n[146] NA            NA            NA            NA            NA           \n[151] \"1H 50M 91S\"  \"1H 50M 98S\"  \"1H 51M 39S\"  \"1H 51M 41S\"  \"1H 51M 56S\" \n[156] \"1H 51M 64S\"  \"1H 51M 95S\"  \"1H 52M 53S\"  \"1H 52M 78S\"  \"1H 53M 4S\"  \n[161] \"4H 15M 73S\"  \"4H 27M 18S\"  \"4H 30M 33S\"  \"4H 30M 77S\"  \"4H 31M 96S\" \n[166] \"4H 32M 45S\"  \"4H 32M 57S\"  \"4H 32M 68S\"  \"4H 34M 16S\"  \"4H 34M 27S\" \n[171] NA            NA            NA            NA            NA           \n[176] NA            NA            NA            NA            NA           \n[181] NA            NA            NA            NA            NA           \n[186] NA            NA            NA            NA            NA           \n[191] NA            NA            NA            NA            NA           \n[196] NA            NA            NA            NA            NA           \n[201] NA            NA            NA            NA            NA           \n[206] NA            NA            NA            NA            NA           \n[211] \"1H 1M 10S\"   \"1H 2M 88S\"   \"1H 2M 89S\"   \"1H 3M 67S\"   \"1H 4M 10S\"  \n[216] \"1H 4M 16S\"   \"1H 4M 24S\"   \"1H 4M 26S\"   \"1H 4M 35S\"   \"1H 4M 43S\"  \n[221] NA            NA            NA            NA            NA           \n[226] NA            NA            NA            NA            NA           \n[231] NA            NA            NA            NA            NA           \n[236] NA            NA            NA            NA            NA           \n[241] \"1H 38M 35S\"  \"1H 38M 88S\"  \"1H 39M 7S\"   \"1H 39M 35S\"  \"1H 39M 63S\" \n[246] \"1H 39M 80S\"  \"1H 39M 82S\"  \"1H 40M 30S\"  \"1H 40M 31S\"  \"1H 40M 50S\" \n[251] \"4H 25M 67S\"  \"4H 28M 11S\"  \"4H 28M 89S\"  \"4H 29M 32S\"  \"4H 31M 64S\" \n[256] \"4H 32M 52S\"  \"4H 32M 65S\"  \"4H 32M 94S\"  \"4H 32M 98S\"  \"4H 34M 70S\" \n[261] \"9H 14M 11S\"  \"9H 24M 43S\"  \"9H 35M 78S\"  \"9H 36M 64S\"  \"9H 39M 27S\" \n[266] \"9H 40M 2S\"   \"9H 41M 48S\"  \"9H 45M 72S\"  \"9H 46M 63S\"  \"9H 47M 9S\"  \n[271] \"15H 17M 24S\" \"15H 32M 19S\" \"15H 45M 57S\" \"15H 47M 40S\" \"15H 52M 94S\"\n[276] \"15H 53M 75S\" \"15H 56M 57S\" \"15H 57M 89S\" \"16H 2M 45S\"  \"16H 3M 38S\" \n[281] NA            NA            NA            NA            NA           \n[286] NA            NA            NA            NA            NA           \n[291] \"1H 45M 5S\"   \"1H 45M 67S\"  \"1H 46M 51S\"  \"1H 48M 84S\"  \"1H 49M 1S\"  \n[296] \"1H 49M 38S\"  \"1H 50M 32S\"  \"1H 50M 43S\"  \"1H 51M 7S\"   \"1H 51M 57S\" \n[301] NA            NA            NA            NA            NA           \n[306] NA            NA            NA            NA            NA           \n[311] \"1H 59M 90S\"  \"2H 1M 18S\"   \"2H 1M 45S\"   \"2H 1M 60S\"   \"2H 1M 66S\"  \n[316] \"2H 1M 77S\"   \"2H 1M 78S\"   \"2H 2M 89S\"   \"2H 3M 19S\"   \"2H 3M 23S\"  \n[321] NA            NA            NA            NA            NA           \n[326] NA            NA            NA            NA            NA           \n[331] \"1H 43M 96S\"  \"1H 48M 70S\"  \"1H 49M 24S\"  \"1H 49M 95S\"  \"1H 49M 96S\" \n[336] \"1H 50M 34S\"  \"1H 50M 47S\"  \"1H 50M 49S\"  \"1H 50M 51S\"  \"1H 50M 76S\" \n[341] \"1H 46M 97S\"  \"1H 48M 74S\"  \"1H 49M 74S\"  \"1H 50M 51S\"  \"1H 50M 78S\" \n[346] \"1H 51M 11S\"  \"1H 51M 24S\"  \"1H 51M 48S\"  \"1H 51M 82S\"  \"1H 51M 83S\" \n[351] NA            NA            NA            NA            NA           \n[356] NA            NA            NA            NA            NA           \n[361] NA            NA            NA            NA            NA           \n[366] NA            NA            NA            NA            NA           \n[371] \"1H 37M 98S\"  \"1H 38M 49S\"  \"1H 39M 9S\"   \"1H 39M 19S\"  \"1H 39M 66S\" \n[376] \"1H 40M 21S\"  \"1H 40M 22S\"  \"1H 40M 44S\"  \"1H 40M 70S\"  \"1H 40M 70S\" \n[381] \"3H 55M 61S\"  \"3H 56M 68S\"  \"3H 56M 88S\"  \"3H 59M 2S\"   \"3H 59M 13S\" \n[386] \"3H 59M 17S\"  \"4H 0M 63S\"   \"4H 1M 14S\"   \"4H 2M 38S\"   \"4H 2M 99S\"  \n[391] NA            NA            NA            NA            NA           \n[396] NA            NA            NA            NA            NA           \n[401] NA            NA            NA            NA            NA           \n[406] NA            NA            NA            NA            NA           \n[411] NA            NA            NA            NA            NA           \n[416] NA            NA            NA            NA            NA           \n[421] NA            NA            NA            NA            NA           \n[426] NA            NA            NA            NA            NA           \n[431] NA            NA            NA            NA            NA           \n[436] NA            NA            NA            NA            NA           \n```\n:::\n:::\n\n\nYikes! Note the warning and look at the output. Some strings failed and turned to `NA`. Looking and the `time` vector again, we see that contains both values like `1:52.83` and `23.87`. If there is only one `:`, we should be able to use `ms()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nms(DAT$time)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] \"23M 29S\"    \"23M 31S\"    \"23M 49S\"    \"23M 71S\"    \"23M 76S\"   \n  [6] \"23M 77S\"    \"23M 77S\"    \"23M 87S\"    \"23M 93S\"    \"24M 2S\"    \n [11] \"51M 5S\"     \"51M 24S\"    \"51M 41S\"    \"51M 56S\"    \"51M 56S\"   \n [16] \"51M 88S\"    \"52M 5S\"     \"52M 5S\"     \"52M 14S\"    \"52M 17S\"   \n [21] \"1M 50.3S\"   \"1M 51.89S\"  \"1M 52.4S\"   \"1M 52.55S\"  \"1M 52.57S\" \n [26] \"1M 52.67S\"  \"1M 52.8S\"   \"1M 52.83S\"  \"1M 52.88S\"  \"1M 52.89S\" \n [31] \"4M 57.37S\"  \"4M 59.22S\"  \"4M 59.78S\"  \"5M 0.06S\"   \"5M 0.21S\"  \n [36] \"5M 0.47S\"   \"5M 1.17S\"   \"5M 1.99S\"   \"5M 2.16S\"   \"5M 2.23S\"  \n [41] \"10M 14.33S\" \"10M 15.4S\"  \"10M 22.59S\" \"10M 22.84S\" \"10M 24.14S\"\n [46] \"10M 24.82S\" \"10M 26.34S\" \"10M 26.89S\" \"10M 33.15S\" \"10M 36.6S\" \n [51] \"16M 58.48S\" \"17M 3.21S\"  \"17M 6.78S\"  \"17M 9.09S\"  \"17M 9.26S\" \n [56] \"17M 12.18S\" \"17M 12.46S\" \"17M 13.58S\" \"17M 21.98S\" \"17M 24.49S\"\n [61] \"55M 66S\"    \"55M 67S\"    \"55M 91S\"    \"56M 11S\"    \"56M 74S\"   \n [66] \"56M 83S\"    \"57M 18S\"    \"57M 36S\"    \"57M 47S\"    \"57M 56S\"   \n [71] \"1M 59.91S\"  \"2M 2.1S\"    \"2M 3.73S\"   \"2M 3.85S\"   \"2M 3.92S\"  \n [76] \"2M 5.1S\"    \"2M 5.56S\"   \"2M 5.71S\"   \"2M 5.76S\"   \"2M 6.13S\"  \n [81] \"1M 1.84S\"   \"1M 3.28S\"   \"1M 3.51S\"   \"1M 3.91S\"   \"1M 4.16S\"  \n [86] \"1M 4.19S\"   \"1M 4.65S\"   \"1M 4.66S\"   \"1M 4.77S\"   \"1M 4.94S\"  \n [91] \"2M 14.83S\"  \"2M 15.62S\"  \"2M 18.99S\"  \"2M 19.06S\"  \"2M 19.78S\" \n [96] \"2M 20.01S\"  \"2M 21.17S\"  \"2M 21.77S\"  \"2M 22.34S\"  \"2M 22.83S\" \n[101] \"54M 76S\"    \"54M 92S\"    \"54M 93S\"    \"55M 23S\"    \"55M 74S\"   \n[106] \"56M 4S\"     \"56M 27S\"    \"56M 42S\"    \"56M 47S\"    \"56M 56S\"   \n[111] \"2M 1.84S\"   \"2M 2.58S\"   \"2M 3.8S\"    \"2M 4.05S\"   \"2M 4.42S\"  \n[116] \"2M 4.81S\"   \"2M 6.4S\"    \"2M 7.12S\"   \"2M 7.33S\"   \"2M 7.42S\"  \n[121] \"2M 0.69S\"   \"2M 3.59S\"   \"2M 3.79S\"   \"2M 4.74S\"   \"2M 5.41S\"  \n[126] \"2M 6.82S\"   \"2M 7.12S\"   \"2M 7.14S\"   \"2M 7.81S\"   \"2M 7.94S\"  \n[131] \"22M 69S\"    \"22M 92S\"    \"22M 93S\"    \"22M 95S\"    \"23M 27S\"   \n[136] \"23M 31S\"    \"23M 33S\"    \"23M 38S\"    \"23M 45S\"    \"23M 47S\"   \n[141] \"50M 65S\"    \"50M 67S\"    \"50M 92S\"    \"51M 19S\"    \"51M 27S\"   \n[146] \"51M 28S\"    \"51M 29S\"    \"51M 37S\"    \"51M 45S\"    \"51M 56S\"   \n[151] \"1M 50.91S\"  \"1M 50.98S\"  \"1M 51.39S\"  \"1M 51.41S\"  \"1M 51.56S\" \n[156] \"1M 51.64S\"  \"1M 51.95S\"  \"1M 52.53S\"  \"1M 52.78S\"  \"1M 53.04S\" \n[161] \"4M 15.73S\"  \"4M 27.18S\"  \"4M 30.33S\"  \"4M 30.77S\"  \"4M 31.96S\" \n[166] \"4M 32.45S\"  \"4M 32.57S\"  \"4M 32.68S\"  \"4M 34.16S\"  \"4M 34.27S\" \n[171] \"25M 94S\"    \"26M 22S\"    \"26M 28S\"    \"26M 57S\"    \"26M 82S\"   \n[176] \"26M 90S\"    \"27M 14S\"    \"27M 14S\"    \"27M 16S\"    \"27M 17S\"   \n[181] \"28M 33S\"    \"28M 96S\"    \"29M 5S\"     \"29M 6S\"     \"29M 9S\"    \n[186] \"29M 9S\"     \"29M 24S\"    \"29M 26S\"    \"29M 46S\"    \"29M 55S\"   \n[191] \"24M 5S\"     \"24M 28S\"    \"24M 58S\"    \"24M 59S\"    \"24M 65S\"   \n[196] \"24M 85S\"    \"25M 5S\"     \"25M 8S\"     \"25M 24S\"    \"25M 34S\"   \n[201] \"54M 65S\"    \"54M 81S\"    \"54M 91S\"    \"55M 11S\"    \"55M 13S\"   \n[206] \"55M 25S\"    \"55M 27S\"    \"55M 45S\"    \"55M 62S\"    \"56M 21S\"   \n[211] \"1M 1.1S\"    \"1M 2.88S\"   \"1M 2.89S\"   \"1M 3.67S\"   \"1M 4.1S\"   \n[216] \"1M 4.16S\"   \"1M 4.24S\"   \"1M 4.26S\"   \"1M 4.35S\"   \"1M 4.43S\"  \n[221] \"19M 98S\"    \"20M 21S\"    \"20M 22S\"    \"20M 36S\"    \"20M 51S\"   \n[226] \"20M 65S\"    \"20M 69S\"    \"20M 71S\"    \"20M 79S\"    \"20M 82S\"   \n[231] \"44M 6S\"     \"44M 21S\"    \"44M 73S\"    \"44M 94S\"    \"45M 24S\"   \n[236] \"45M 31S\"    \"45M 32S\"    \"45M 45S\"    \"45M 50S\"    \"45M 50S\"   \n[241] \"1M 38.35S\"  \"1M 38.88S\"  \"1M 39.07S\"  \"1M 39.35S\"  \"1M 39.63S\" \n[246] \"1M 39.8S\"   \"1M 39.82S\"  \"1M 40.3S\"   \"1M 40.31S\"  \"1M 40.5S\"  \n[251] \"4M 25.67S\"  \"4M 28.11S\"  \"4M 28.89S\"  \"4M 29.32S\"  \"4M 31.64S\" \n[256] \"4M 32.52S\"  \"4M 32.65S\"  \"4M 32.94S\"  \"4M 32.98S\"  \"4M 34.7S\"  \n[261] \"9M 14.11S\"  \"9M 24.43S\"  \"9M 35.78S\"  \"9M 36.64S\"  \"9M 39.27S\" \n[266] \"9M 40.02S\"  \"9M 41.48S\"  \"9M 45.72S\"  \"9M 46.63S\"  \"9M 47.09S\" \n[271] \"15M 17.24S\" \"15M 32.19S\" \"15M 45.57S\" \"15M 47.4S\"  \"15M 52.94S\"\n[276] \"15M 53.75S\" \"15M 56.57S\" \"15M 57.89S\" \"16M 2.45S\"  \"16M 3.38S\" \n[281] \"46M 99S\"    \"47M 57S\"    \"49M 32S\"    \"49M 97S\"    \"50M 3S\"    \n[286] \"50M 29S\"    \"50M 35S\"    \"50M 41S\"    \"50M 51S\"    \"50M 59S\"   \n[291] \"1M 45.05S\"  \"1M 45.67S\"  \"1M 46.51S\"  \"1M 48.84S\"  \"1M 49.01S\" \n[296] \"1M 49.38S\"  \"1M 50.32S\"  \"1M 50.43S\"  \"1M 51.07S\"  \"1M 51.57S\" \n[301] \"54M 88S\"    \"55M 80S\"    \"55M 92S\"    \"56M 3S\"     \"56M 27S\"   \n[306] \"56M 35S\"    \"56M 36S\"    \"56M 45S\"    \"56M 49S\"    \"56M 49S\"   \n[311] \"1M 59.9S\"   \"2M 1.18S\"   \"2M 1.45S\"   \"2M 1.6S\"    \"2M 1.66S\"  \n[316] \"2M 1.77S\"   \"2M 1.78S\"   \"2M 2.89S\"   \"2M 3.19S\"   \"2M 3.23S\"  \n[321] \"47M 45S\"    \"47M 56S\"    \"47M 80S\"    \"48M 74S\"    \"48M 91S\"   \n[326] \"49M 26S\"    \"49M 31S\"    \"49M 34S\"    \"49M 68S\"    \"49M 74S\"   \n[331] \"1M 43.96S\"  \"1M 48.7S\"   \"1M 49.24S\"  \"1M 49.95S\"  \"1M 49.96S\" \n[336] \"1M 50.34S\"  \"1M 50.47S\"  \"1M 50.49S\"  \"1M 50.51S\"  \"1M 50.76S\" \n[341] \"1M 46.97S\"  \"1M 48.74S\"  \"1M 49.74S\"  \"1M 50.51S\"  \"1M 50.78S\" \n[346] \"1M 51.11S\"  \"1M 51.24S\"  \"1M 51.48S\"  \"1M 51.82S\"  \"1M 51.83S\" \n[351] \"19M 47S\"    \"19M 63S\"    \"19M 96S\"    \"20M 8S\"     \"20M 10S\"   \n[356] \"20M 14S\"    \"20M 18S\"    \"20M 22S\"    \"20M 25S\"    \"20M 28S\"   \n[361] \"43M 28S\"    \"43M 69S\"    \"43M 74S\"    \"44M 43S\"    \"44M 57S\"   \n[366] \"44M 59S\"    \"44M 81S\"    \"44M 81S\"    \"44M 83S\"    \"44M 87S\"   \n[371] \"1M 37.98S\"  \"1M 38.49S\"  \"1M 39.09S\"  \"1M 39.19S\"  \"1M 39.66S\" \n[376] \"1M 40.21S\"  \"1M 40.22S\"  \"1M 40.44S\"  \"1M 40.7S\"   \"1M 40.7S\"  \n[381] \"3M 55.61S\"  \"3M 56.68S\"  \"3M 56.88S\"  \"3M 59.02S\"  \"3M 59.13S\" \n[386] \"3M 59.17S\"  \"4M 0.63S\"   \"4M 1.14S\"   \"4M 2.38S\"   \"4M 2.99S\"  \n[391] \"22M 32S\"    \"22M 50S\"    \"22M 84S\"    \"23M 0S\"     \"23M 24S\"   \n[396] \"23M 45S\"    \"23M 72S\"    \"23M 74S\"    \"23M 85S\"    \"23M 87S\"   \n[401] \"24M 73S\"    \"24M 81S\"    \"24M 88S\"    \"25M 10S\"    \"25M 20S\"   \n[406] \"25M 47S\"    \"25M 55S\"    \"25M 63S\"    \"26M 1S\"     \"26M 5S\"    \n[411] \"20M 60S\"    \"21M 38S\"    \"21M 48S\"    \"21M 58S\"    \"21M 60S\"   \n[416] \"21M 81S\"    \"21M 83S\"    \"22M 0S\"     \"22M 6S\"     \"22M 7S\"    \n[421] \"47M 1S\"     \"47M 72S\"    \"48M 39S\"    \"48M 50S\"    \"48M 54S\"   \n[426] \"48M 82S\"    \"49M 0S\"     \"49M 45S\"    \"49M 52S\"    \"49M 60S\"   \n[431] \"54M 52S\"    \"55M 15S\"    \"55M 21S\"    \"55M 47S\"    \"55M 62S\"   \n[436] \"56M 4S\"     \"56M 13S\"    \"56M 19S\"    \"56M 35S\"    \"56M 48S\"   \n```\n:::\n:::\n\n\nGreat! All elements are in the form of `\"xxM XXs\"`. But does **{lubridate}** also convert seconds to a numeric value when using `period_to_seconds()`? If loaded, we can also remove the name of the library when calling the functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(period_to_seconds(ms(DAT$time)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nSo let's go ahead and modify the character vector named `time` to a numeric vector representing seconds. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nperiod_to_seconds(ms(DAT$time))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 1409.00 1411.00 1429.00 1451.00 1456.00 1457.00 1457.00 1467.00 1473.00\n [10] 1442.00 3065.00 3084.00 3101.00 3116.00 3116.00 3148.00 3125.00 3125.00\n [19] 3134.00 3137.00  110.30  111.89  112.40  112.55  112.57  112.67  112.80\n [28]  112.83  112.88  112.89  297.37  299.22  299.78  300.06  300.21  300.47\n [37]  301.17  301.99  302.16  302.23  614.33  615.40  622.59  622.84  624.14\n [46]  624.82  626.34  626.89  633.15  636.60 1018.48 1023.21 1026.78 1029.09\n [55] 1029.26 1032.18 1032.46 1033.58 1041.98 1044.49 3366.00 3367.00 3391.00\n [64] 3371.00 3434.00 3443.00 3438.00 3456.00 3467.00 3476.00  119.91  122.10\n [73]  123.73  123.85  123.92  125.10  125.56  125.71  125.76  126.13   61.84\n [82]   63.28   63.51   63.91   64.16   64.19   64.65   64.66   64.77   64.94\n [91]  134.83  135.62  138.99  139.06  139.78  140.01  141.17  141.77  142.34\n[100]  142.83 3316.00 3332.00 3333.00 3323.00 3374.00 3364.00 3387.00 3402.00\n[109] 3407.00 3416.00  121.84  122.58  123.80  124.05  124.42  124.81  126.40\n[118]  127.12  127.33  127.42  120.69  123.59  123.79  124.74  125.41  126.82\n[127]  127.12  127.14  127.81  127.94 1389.00 1412.00 1413.00 1415.00 1407.00\n[136] 1411.00 1413.00 1418.00 1425.00 1427.00 3065.00 3067.00 3092.00 3079.00\n[145] 3087.00 3088.00 3089.00 3097.00 3105.00 3116.00  110.91  110.98  111.39\n[154]  111.41  111.56  111.64  111.95  112.53  112.78  113.04  255.73  267.18\n[163]  270.33  270.77  271.96  272.45  272.57  272.68  274.16  274.27 1594.00\n[172] 1582.00 1588.00 1617.00 1642.00 1650.00 1634.00 1634.00 1636.00 1637.00\n[181] 1713.00 1776.00 1745.00 1746.00 1749.00 1749.00 1764.00 1766.00 1786.00\n[190] 1795.00 1445.00 1468.00 1498.00 1499.00 1505.00 1525.00 1505.00 1508.00\n[199] 1524.00 1534.00 3305.00 3321.00 3331.00 3311.00 3313.00 3325.00 3327.00\n[208] 3345.00 3362.00 3381.00   61.10   62.88   62.89   63.67   64.10   64.16\n[217]   64.24   64.26   64.35   64.43 1238.00 1221.00 1222.00 1236.00 1251.00\n[226] 1265.00 1269.00 1271.00 1279.00 1282.00 2646.00 2661.00 2713.00 2734.00\n[235] 2724.00 2731.00 2732.00 2745.00 2750.00 2750.00   98.35   98.88   99.07\n[244]   99.35   99.63   99.80   99.82  100.30  100.31  100.50  265.67  268.11\n[253]  268.89  269.32  271.64  272.52  272.65  272.94  272.98  274.70  554.11\n[262]  564.43  575.78  576.64  579.27  580.02  581.48  585.72  586.63  587.09\n[271]  917.24  932.19  945.57  947.40  952.94  953.75  956.57  957.89  962.45\n[280]  963.38 2859.00 2877.00 2972.00 3037.00 3003.00 3029.00 3035.00 3041.00\n[289] 3051.00 3059.00  105.05  105.67  106.51  108.84  109.01  109.38  110.32\n[298]  110.43  111.07  111.57 3328.00 3380.00 3392.00 3363.00 3387.00 3395.00\n[307] 3396.00 3405.00 3409.00 3409.00  119.90  121.18  121.45  121.60  121.66\n[316]  121.77  121.78  122.89  123.19  123.23 2865.00 2876.00 2900.00 2954.00\n[325] 2971.00 2966.00 2971.00 2974.00 3008.00 3014.00  103.96  108.70  109.24\n[334]  109.95  109.96  110.34  110.47  110.49  110.51  110.76  106.97  108.74\n[343]  109.74  110.51  110.78  111.11  111.24  111.48  111.82  111.83 1187.00\n[352] 1203.00 1236.00 1208.00 1210.00 1214.00 1218.00 1222.00 1225.00 1228.00\n[361] 2608.00 2649.00 2654.00 2683.00 2697.00 2699.00 2721.00 2721.00 2723.00\n[370] 2727.00   97.98   98.49   99.09   99.19   99.66  100.21  100.22  100.44\n[379]  100.70  100.70  235.61  236.68  236.88  239.02  239.13  239.17  240.63\n[388]  241.14  242.38  242.99 1352.00 1370.00 1404.00 1380.00 1404.00 1425.00\n[397] 1452.00 1454.00 1465.00 1467.00 1513.00 1521.00 1528.00 1510.00 1520.00\n[406] 1547.00 1555.00 1563.00 1561.00 1565.00 1260.00 1298.00 1308.00 1318.00\n[415] 1320.00 1341.00 1343.00 1320.00 1326.00 1327.00 2821.00 2892.00 2919.00\n[424] 2930.00 2934.00 2962.00 2940.00 2985.00 2992.00 3000.00 3292.00 3315.00\n[433] 3321.00 3347.00 3362.00 3364.00 3373.00 3379.00 3395.00 3408.00\n```\n:::\n:::\n\n\nPerfect! Let's `mutate()` that variable in the data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  slice(., 1:5) %>%   # rows 1 through 5\n  mutate(., time = period_to_seconds(ms(time)))  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  time             name year   event   team\n1 1409 Jocelyn Crawford 2019 50 FREE Athena\n2 1411    Ava Sealander 2022 50 FREE Athena\n3 1429        Kelly Ngo 2016 50 FREE Athena\n4 1451        Helen Liu 2014 50 FREE Athena\n5 1456      Michele Kee 2014 50 FREE Athena\n```\n:::\n:::\n\n\nLet's look at `DAT` now and see those seconds. You can look at the entire data frame if you wish rather than its `head()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(DAT)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   time             name year   event   team\n1 23.29 Jocelyn Crawford 2019 50 FREE Athena\n2 23.31    Ava Sealander 2022 50 FREE Athena\n3 23.49        Kelly Ngo 2016 50 FREE Athena\n4 23.71        Helen Liu 2014 50 FREE Athena\n5 23.76      Michele Kee 2014 50 FREE Athena\n6 23.77 Natalia Orbach-M 2020 50 FREE Athena\n```\n:::\n:::\n\n\nThe data frame has not changed. The final step is to assign assign the returned data frame to an object. Remove the `slice()` so we get the entire data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT <- DAT %>%\n  mutate(., time = period_to_seconds(ms(time)))  \n```\n:::\n\n\n\nNow let's write this to `/data`. But we don't want to overwrite this file. **{here}** won't be as effective but we can concatenate the `file_name` string object with a prefix like `\"cleaned\"` using the `paste()` function in `base R`. We will add a hyphen, `-`, by passing it to the `sep` argument. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(\"cleaned\", file_name, sep = \"-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"cleaned-cms-top-all-time-2023-swim.xlsx\"\n```\n:::\n:::\n\n\nWhen paired with `here::here()`, does the full file path look right?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::here(\"data\", paste(\"cleaned\", file_name, sep = \"-\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"C:/Users/gcook/Sync/git/fods24/data/cleaned-cms-top-all-time-2023-swim.xlsx\"\n```\n:::\n:::\n\n\nWe also want to write a `.csv` file. Let's use `gsub()` to look or the string pattern `\".xlxs\"` and replace it with `\".csv\"` for the file path string.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_name <- gsub(pattern = \".xlsx\", \n                 replacement = \".csv\", \n                 x = here::here(\"data\", paste(\"cleaned\", file_name, sep = \"-\"))\n                 )\n```\n:::\n\n\n\nGot our new file name! Let's write!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::write_csv(DAT, new_name)\n```\n:::\n\n\nDone!\n\n# **Quick Summary Using `base R`**\n\nIf you want a quick summary of data, `summary()` will provide some basic information for you. You can pass a data frame to the function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(DAT)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      time            name               year              event          \n Min.   :  61.1   Length:440         Length:440         Length:440        \n 1st Qu.: 123.9   Class :character   Class :character   Class :character  \n Median :1115.7   Mode  :character   Mode  :character   Mode  :character  \n Mean   :1309.4                                                           \n 3rd Qu.:2721.0                                                           \n Max.   :3476.0                                                           \n     team          \n Length:440        \n Class :character  \n Mode  :character  \n                   \n                   \n                   \n```\n:::\n:::\n\n\n\n# **Summarizing Data Using {dplyr}**\n\nHowever, there are many ways to summarize data. To introduce data summary techniques using **{dplyr}**, we will open `DAT` and use `dplyr::summarise()` or `dplyr::summarize()` to summarize the data. The `summarise()` function works similar to `mutate()` insofar as it creates variables but it differs insofar as the data frame returned from `summarise()` contains only the variable(s) referenced in as part of that summary process. This includes some function calls immediately prior to `summarize()`. \n\nIn the example below, we summarize by creating a new variable which is set to represent some data summary technique. In essence, summarizing is for descriptive statistics. Using `mean()`, we can summarize the data by taking the mean of the `time` variable.\n\n```\nsummarize(.data, \n   ..., \n   .by = NULL, \n   .groups = NULL\n   )\n```\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  summarise(., \n            mean = mean(time, na.rm = T),\n            )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      mean\n1 1309.388\n```\n:::\n:::\n\n\n\nNotice what is returned is a single value reflecting the mean of all the data in the data frame. We could have obtained the same without using **{dplyr}**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(DAT$time, na.rm = T)        # $ notation\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1309.388\n```\n:::\n:::\n\n\nBut we lose flexibility of easily adding new summary procedures. We can summarize by two name-value pair functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  summarise(., \n            mean = mean(time, na.rm = T),\n            sd   = sd(time, na.rm = T)\n            )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      mean       sd\n1 1309.388 1225.964\n```\n:::\n:::\n\n\nNow there is a mean and standard deviation for price. You can also add the sample size using `dplyr::n()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  summarise(., \n            mean = mean(time, na.rm = T),\n            sd   = sd(time, na.rm = T),\n            n    = n()\n            )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      mean       sd   n\n1 1309.388 1225.964 440\n```\n:::\n:::\n\n\n\n# **Summarizing `across()` Multiple Variables**\n\nSummarizing a single variable is useful but if you want to summarize by many, you likely do not want to code a new line for each variable. In such cases, you can use `across()` as a helper function as was used for creating new variables with `mutate()` (see previous lesson).  \n\n`across()` has three main arguments:\n\n- `.cols`: specifies the columns to summarize across\n- `.fns`: specifies the function(s) for the summary\n- `.names`: specifies the output variable names \n\nRemember `across()` will want you to pass the columns to summarize by, `.cols`, the function for how to summarize, `.fns`, and the names for how to name the new variables, `.names` (which will be `NULL` by default). The `.x` here stands for passing the vector to the mean function and not the data frame. More on `~` and `.x` later.\n\n## *Summarize across by numeric variables:*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  summarise(., across(.cols = where(is.numeric), \n                      .fns  = ~mean(.x, na.rm = TRUE))\n            )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      time\n1 1309.388\n```\n:::\n:::\n\n\nWell, that's now actually impressive because there is only one numeric variable. What if we had more that were piped to `summarize()`?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  mutate(., \n         num1 = time,\n         num2 = time,\n         num3 = time\n         ) %>%\n  summarise(., across(.cols = where(is.numeric), \n                      .fns  = ~mean(.x, na.rm = TRUE))\n            )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      time     num1     num2     num3\n1 1309.388 1309.388 1309.388 1309.388\n```\n:::\n:::\n\n\nThat was easy.\n\n\nBecause `across()` is so powerful, let's just add another variable to the data frame for using in examples. You might also wish to reorder the position of variables in the data frame so that they are grouped in some way. We can use `dplyr::relocate()` to accomplish this. We will move the `time` column to the position `.before` one of the new variables using `relocate(., time, .before = min)`.\n\nDoing so will also show you some ways to create variables. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT <- DAT %>%\n  mutate(., \n         sec = time,  # will be redundant with time but named accurately\n         min  = time/60,\n         hour = time/(60*60)\n         ) %>%\n  relocate(., time, .before = sec)\n```\n:::\n\n\nTake a look:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(DAT)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              name year   event   team time  sec      min      hour\n1 Jocelyn Crawford 2019 50 FREE Athena 1409 1409 23.48333 0.3913889\n2    Ava Sealander 2022 50 FREE Athena 1411 1411 23.51667 0.3919444\n3        Kelly Ngo 2016 50 FREE Athena 1429 1429 23.81667 0.3969444\n4        Helen Liu 2014 50 FREE Athena 1451 1451 24.18333 0.4030556\n5      Michele Kee 2014 50 FREE Athena 1456 1456 24.26667 0.4044444\n6 Natalia Orbach-M 2020 50 FREE Athena 1457 1457 24.28333 0.4047222\n```\n:::\n:::\n\n\n\nVariable names created with `across()` is controlled using the `.names` argument. The default is equivalent to `.names = {.col}`, which means that the name(s) are inherited from the `.cols` argument; the names are a stand-in for the name specification. If you wish to have control over the names, you can pass a string that that either appends  (e.g.,`\"{.col}suffix\"`) or prepends (e.g.,`\"prefix{.col}\"`) a string to each column name. This string looks odd because it's a special *glue* specification that glues together with a string with an object. We will use this concept later when using the **{glue}** library. \n\nWhen modifying `.names`, include a character like `\"_\"` (e.g.,`\"{.col}_suffix\"`) so that the column names and the appended text are separated, making the name easily legible. If you summarize to create means, a good suggestion is something like (e.g.,`\"{.col}_mean\"` or (e.g.,`\"{.col}_mn\"`)) so that you know the variable is a mean. If you prefer the function name first, you can use a prefix (e.g.,`\"mean_{.col}\"`).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  summarise(., across(.cols = c(\"sec\", \"min\", \"hour\"), \n                      .fns  = ~mean(.x, na.rm = TRUE),\n                      .names = \"{.col}_mean\"\n                      )\n            )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  sec_mean min_mean hour_mean\n1 1309.388 21.82313 0.3637189\n```\n:::\n:::\n\n\nYou can see how all variables in the summary end in `\"_mean\"`.\n\n\nYou can also glue the function and the column names together by passing `.names = \"{.col}_{.fn}\"`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  summarise(., across(.cols = c(\"sec\", \"min\", \"hour\"), \n                      .fns  = ~mean(.x, na.rm = TRUE),\n                      .names = \"{.col}_{.fn}\"\n                      )\n            )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     sec_1    min_1    hour_1\n1 1309.388 21.82313 0.3637189\n```\n:::\n:::\n\n\nYou you will see there is a number that is appended to the variable name. This is because there is only one function passed to `.fns`. You can pass more using a special object called a list (see `?list`). Unlike vectors, elements of lists need not be the same kind. Elements of lists can combinations of characters, numbers, data frames, functions, etc.\n\n\n## *Passing multiple functions from a `list()` in `across()`*\n\nPassing functions as a list requires a little fancy coding. We will pass two functions as a `list` so that we can calculate both the `mean()` and the `sd()` on the variables passed to `across()`.  \n\nA `list` is a special object (e.g., container) for which its elements can be different types of objects. Whereas elements of `vectors` can be only character or only numeric, elements of lists can hold different object. One element can be a numeric vector, another element a data frame, another element a character vector, etc. Many functions used in R will actually return lists for which elements contain different types of objects.\n\nOK back to two or more functions. If you pass a `list()` with arguments for the `mean` and the `sd` (e.g., `list(mean, sd)`, you can summarize by both. If you want to prevent errors (yes you do) and want to keep the summaries separate (probably so), you can modify `.names` to pass both the column and the function (e.g., `\"{.col}_{.fn}\"`). The underscore is not needed here; it only helps with readability of the variables so that you don't end up with variable names like `var1mean` but instead `var1_mean`.\n\nLet's pass the summary procedures as a `list` to include measures of mean and standard deviation for the variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  summarise(., across(.cols  = c(\"sec\", \"min\", \"hour\"), \n                      .fns   = list(mean, sd),\n                      .names = \"{.col}_{.fn}\")\n            )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     sec_1    sec_2    min_1    min_2    hour_1    hour_2\n1 1309.388 1225.964 21.82313 20.43274 0.3637189 0.3405456\n```\n:::\n:::\n\n\nWell those are not exactly the names we want but it illustrates how names are created. Because we have two summary functions for each column variable passed to `across()`, they are enumerated according to the order in the list (e.g., mean then standard deviation).\n\n### *Fixing `.names` when passing lists to `.cols` in `across()`*\n\nEnumeration is not helpful for remembering variable names. There are different ways to do fix this problem, some of which may be better under certain scenarios. You have to determine what approach is best but I'll lay out some limitations. If you pass only the functions into the list, then when you pass `{.fn}` to `.names`, the variable names in the returned data frame will take on a numeric value representing the order/element position of the functions as you entered them in the `list`. In this coding instance, means would be named with`\"_1\"` and standard deviation names with `\"_2\"`. This approach, however, leads to confusing variable names because you have to remember which is 1 and which is 2 and of course explain this to anyone with whom you share the data. Let's take a look. \n\nA better approach could be to assign the `mean` and `sd` functions their own names in the `list()` function call. By doing so, the name is appended and the new variable is named meaningfully. \n\nLet's modify what we pass to `.fns` by passing a list containing 3 functions (e.g., `mean()`, `sd()`, and `length()`) and give each there name. I know this part is confusing because the `()` are dropped inside the list. This is just how `R` works. Don't blame the messenger.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  summarise(., across(.cols = c(\"sec\", \"min\", \"hour\"), \n                      .fns  = list(mean = mean, \n                                   sd = sd,\n                                   n = length\n                                   ),\n                      .names = \"{.col}_{.fn}\")\n            )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  sec_mean   sec_sd sec_n min_mean   min_sd min_n hour_mean   hour_sd hour_n\n1 1309.388 1225.964   440 21.82313 20.43274   440 0.3637189 0.3405456    440\n```\n:::\n:::\n\n\nImportantly, however, certain functions like `mean()` will operate in ways you might not expect. One one hand, it does what we expect when all elements can be used to calculate the mean. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(DAT$time)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1309.388\n```\n:::\n:::\n\n\nOn the other hand, if there is a missing value, it does not computer the mean but instead something else. Let's add an `NA` to the vector using `c()` to see what happens.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(c(DAT$time, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n#### *Understanding `NA`s when passing lists to `.cols` in `across()`*\n\nThe `mean()` function returns `NA` rather than a mean. If there is just one `NA`, `mean()` returns `NA`. By design this is actually good. \n\nLet's also try `sd()` for the standard deviation of a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsd(c(DAT$time, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nThe median of a vector, `median()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmedian(c(DAT$time, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nThe length of a vector, `length()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(c(DAT$time, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 441\n```\n:::\n:::\n\n\nWell, that's interesting. By default `length()` will return the number of elements of the vector including `NA`s but by default `mean()` will not return the mean of a vector with `NA`s because `na.rm = FALSE` by default. If you wish to calculate the mean by removing the `NA`s, pass `na.rm = TRUE`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(c(DAT$time, NA), na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1309.388\n```\n:::\n:::\n\n\nMake note, however, that the length of this vector without `NA`s is **shorter** than the length with `NA`s. We can test this hypothesis on a vector with and without the `NA` by using `na.omit()` to omit any of them. Using our vector we added an `NA`, let's omit it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nna.omit(c(DAT$time, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 1409.00 1411.00 1429.00 1451.00 1456.00 1457.00 1457.00 1467.00 1473.00\n [10] 1442.00 3065.00 3084.00 3101.00 3116.00 3116.00 3148.00 3125.00 3125.00\n [19] 3134.00 3137.00  110.30  111.89  112.40  112.55  112.57  112.67  112.80\n [28]  112.83  112.88  112.89  297.37  299.22  299.78  300.06  300.21  300.47\n [37]  301.17  301.99  302.16  302.23  614.33  615.40  622.59  622.84  624.14\n [46]  624.82  626.34  626.89  633.15  636.60 1018.48 1023.21 1026.78 1029.09\n [55] 1029.26 1032.18 1032.46 1033.58 1041.98 1044.49 3366.00 3367.00 3391.00\n [64] 3371.00 3434.00 3443.00 3438.00 3456.00 3467.00 3476.00  119.91  122.10\n [73]  123.73  123.85  123.92  125.10  125.56  125.71  125.76  126.13   61.84\n [82]   63.28   63.51   63.91   64.16   64.19   64.65   64.66   64.77   64.94\n [91]  134.83  135.62  138.99  139.06  139.78  140.01  141.17  141.77  142.34\n[100]  142.83 3316.00 3332.00 3333.00 3323.00 3374.00 3364.00 3387.00 3402.00\n[109] 3407.00 3416.00  121.84  122.58  123.80  124.05  124.42  124.81  126.40\n[118]  127.12  127.33  127.42  120.69  123.59  123.79  124.74  125.41  126.82\n[127]  127.12  127.14  127.81  127.94 1389.00 1412.00 1413.00 1415.00 1407.00\n[136] 1411.00 1413.00 1418.00 1425.00 1427.00 3065.00 3067.00 3092.00 3079.00\n[145] 3087.00 3088.00 3089.00 3097.00 3105.00 3116.00  110.91  110.98  111.39\n[154]  111.41  111.56  111.64  111.95  112.53  112.78  113.04  255.73  267.18\n[163]  270.33  270.77  271.96  272.45  272.57  272.68  274.16  274.27 1594.00\n[172] 1582.00 1588.00 1617.00 1642.00 1650.00 1634.00 1634.00 1636.00 1637.00\n[181] 1713.00 1776.00 1745.00 1746.00 1749.00 1749.00 1764.00 1766.00 1786.00\n[190] 1795.00 1445.00 1468.00 1498.00 1499.00 1505.00 1525.00 1505.00 1508.00\n[199] 1524.00 1534.00 3305.00 3321.00 3331.00 3311.00 3313.00 3325.00 3327.00\n[208] 3345.00 3362.00 3381.00   61.10   62.88   62.89   63.67   64.10   64.16\n[217]   64.24   64.26   64.35   64.43 1238.00 1221.00 1222.00 1236.00 1251.00\n[226] 1265.00 1269.00 1271.00 1279.00 1282.00 2646.00 2661.00 2713.00 2734.00\n[235] 2724.00 2731.00 2732.00 2745.00 2750.00 2750.00   98.35   98.88   99.07\n[244]   99.35   99.63   99.80   99.82  100.30  100.31  100.50  265.67  268.11\n[253]  268.89  269.32  271.64  272.52  272.65  272.94  272.98  274.70  554.11\n[262]  564.43  575.78  576.64  579.27  580.02  581.48  585.72  586.63  587.09\n[271]  917.24  932.19  945.57  947.40  952.94  953.75  956.57  957.89  962.45\n[280]  963.38 2859.00 2877.00 2972.00 3037.00 3003.00 3029.00 3035.00 3041.00\n[289] 3051.00 3059.00  105.05  105.67  106.51  108.84  109.01  109.38  110.32\n[298]  110.43  111.07  111.57 3328.00 3380.00 3392.00 3363.00 3387.00 3395.00\n[307] 3396.00 3405.00 3409.00 3409.00  119.90  121.18  121.45  121.60  121.66\n[316]  121.77  121.78  122.89  123.19  123.23 2865.00 2876.00 2900.00 2954.00\n[325] 2971.00 2966.00 2971.00 2974.00 3008.00 3014.00  103.96  108.70  109.24\n[334]  109.95  109.96  110.34  110.47  110.49  110.51  110.76  106.97  108.74\n[343]  109.74  110.51  110.78  111.11  111.24  111.48  111.82  111.83 1187.00\n[352] 1203.00 1236.00 1208.00 1210.00 1214.00 1218.00 1222.00 1225.00 1228.00\n[361] 2608.00 2649.00 2654.00 2683.00 2697.00 2699.00 2721.00 2721.00 2723.00\n[370] 2727.00   97.98   98.49   99.09   99.19   99.66  100.21  100.22  100.44\n[379]  100.70  100.70  235.61  236.68  236.88  239.02  239.13  239.17  240.63\n[388]  241.14  242.38  242.99 1352.00 1370.00 1404.00 1380.00 1404.00 1425.00\n[397] 1452.00 1454.00 1465.00 1467.00 1513.00 1521.00 1528.00 1510.00 1520.00\n[406] 1547.00 1555.00 1563.00 1561.00 1565.00 1260.00 1298.00 1308.00 1318.00\n[415] 1320.00 1341.00 1343.00 1320.00 1326.00 1327.00 2821.00 2892.00 2919.00\n[424] 2930.00 2934.00 2962.00 2940.00 2985.00 2992.00 3000.00 3292.00 3315.00\n[433] 3321.00 3347.00 3362.00 3364.00 3373.00 3379.00 3395.00 3408.00\nattr(,\"na.action\")\n[1] 441\nattr(,\"class\")\n[1] \"omit\"\n```\n:::\n:::\n\n\nAnd then get the length when `NA`s are omitted:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(na.omit(c(DAT$time, NA)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 440\n```\n:::\n:::\n\n\nThis behavior is important because if you want to obtain the mean of a variable with `NA`s and the sample size using `length()`, your sample size will be inaccurate.\n\nIn order to see these operations on a data frame and in the context of `dplyr::summarize()`, let's modify the data frame to include an additional row with some mission values. One simple approach is to use `base R` to use `rbind()` to bind a new row to the end of the data frame. In this case, the contents of that new row will be the same as the first row of the data frame (e.g., `DAT[1,]`). Then the name will be changed and some values will be made missing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT <- rbind(DAT, \n             DAT[1,]\n             )\n```\n:::\n\n\nModify the cells in the data frame using bracket notation from `base R`. When using brackets, the data frame can be referenced using row and column arguments.\n\nExamples:\n\n```\nDAT[]       # all rows and columns\n\nDAT[,]      # all rows and columns (preferred separation with comma)\n\nDAT[1, ]    # row 1, all columns\n\nDAT[,1]     # all rows, column 1\n\nDAT[1:5, \"name\"]    # rows 1 through 5, \"name\" column\n\nDAT[, c(\"name\", \"year\"]    # all rows, \"name\" and \"year\" columns\n\nDAT[15, \"name\"]    # row 15 through 5, \"name\" column\n```\n\nYou can also obtain the dimensions of a data frame using `dim()` from `base R`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(DAT)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 441   8\n```\n:::\n:::\n\n\n`dim()` returns a vector with two elements: the number of rows and the number of columns. We can use this to reference the last row in the data frame in order to modify it for this example. \n\nFollowing from above, examine the last row, change the `\"name\"` to \"Anonymous\" and then put `NA`s in the `\"sec\"` and `\"min\"` columns for the same row. Remember, vectors are pure characters or numeric, they cannot contain a mixture of them. Because `\"name\"` is character vector and `\"sec\"` and `\"min\"` are numeric vectors, we need to fix them separately. There are other ways to accomplish this goal but this example illustrates the approach in `base R` so that you have some exposure.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT[dim(DAT)[1], ]                              # the current row contents\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                name year   event   team time  sec      min      hour\n441 Jocelyn Crawford 2019 50 FREE Athena 1409 1409 23.48333 0.3913889\n```\n:::\n\n```{.r .cell-code}\nDAT[dim(DAT)[1], \"name\"] <- \"Anonymous\"         # make name anonymous\n\nDAT[dim(DAT)[1], c(\"sec\", \"min\")] <- c(NA, NA)  # set these cells to NA\n```\n:::\n\n\nAre `NA`s across the last row now?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>% tail()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             name year               event   team time  sec      min      hour\n436 Aaron Lutzker 2019 100 BRST-Relay Spl.   Stag 3364 3364 56.06667 0.9344444\n437  Sean Hoerger 2020 100 BRST-Relay Spl.   Stag 3373 3373 56.21667 0.9369444\n438   Tyler Welty 2017 100 BRST-Relay Spl.   Stag 3379 3379 56.31667 0.9386111\n439  Brad Perfect 2013 100 BRST-Relay Spl.   Stag 3395 3395 56.58333 0.9430556\n440  Grant Murray 2018 100 BRST-Relay Spl.   Stag 3408 3408 56.80000 0.9466667\n441     Anonymous 2019             50 FREE Athena 1409   NA       NA 0.3913889\n```\n:::\n:::\n\n\n#### *Comparing some functionality when passing lists to `.cols` in `across()`*\n\nWhen functions do not contain argument for dealing with `NA`s, there is `na.omit()`, a function that takes an object and removes `NA`s. So you can just pass the variable to `na.omit()` and then wrap it in the metric function of interest. Also, because `na.rm = T` cannot be used for `length()`, `na.omit()` offers consistency across all functions and as a result, I believe, less confusion.\n\nUnfortunately, accomplishing this task can be rather tricky and requires some new syntax. This requires usage of what's called a \"lambda\" technique. You will want to incorporate `~` and `.x` into your code. The `~` is used to indicate that you are supplying a lambda function and use of `.x` is to indicate where the variable in `across()` is used. Using this type of syntax, we can pass functions to the `.fns` argument that operate across a set of variables. The `?across()` documentation calls this \"a **{purrr}**-style lambda\" in the arguments section. This approach can be a little bit confusing, so I’m going to show you an example, and then walk through it step by step. You can always create code snippets so you don't have to rely on memory write complicated code like this.\n\nAnyway, we will precede the function with `~` and reference the vector using `.x`. Let's do this and change the `.fns` argument slightly.\n\nHere is a general example:\n\n```\nname = ~function(na.omit(.x))\n```\n\nWe will summarize only `time` and `sec` because those variables are identical except for the row we added. We will also add `dplyr::n()` to see what's going on with that function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  summarise(., across(.cols = c(\"time\", \"sec\"), \n                      .fns  = list(mean = ~mean(na.omit(.x)),\n                                   #sd = ~sd(na.omit(.x)),\n                                   len = ~length(na.omit(.x)),\n                                   n = ~dplyr::n()\n                                   ),\n                      .names = \"{.col}_{.fn}\"\n                      )\n            ) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  time_mean time_len time_n sec_mean sec_len sec_n\n1  1309.614      441    441 1309.388     440   441\n```\n:::\n:::\n\n\nSo what happened? The means and lengths for `time` and `sec` are not the same. Means differ because they are calculated by different values depending on the presence of `NA`s. But notice that the n's are the same based on `dplyr::n()`. How can the means and differ if the n's are the same?  \n\nSo what's the point of all of this? Well, you need to be careful not to apply functions and assume they are doing what you believe you are doing. You always need to be smarter than the code you use. Also, there is no single answer for dealing with data. Sometimes one approach will be appropriate and in other instances another approach will be. You as the data scientist need to know that there are different methods so that you an decide where to apply those different methods. \n\n\n## **Summarize by Groups Using `group_by()`**\n\n### *Identifying how to group*\n\nWhen you have subgroups in your data, you will often want to create summary statistics by those group levels. A typical grouping approach is by some categorical or factor variable present in a data frame. Using `glympse()`, we can view all variables to see what might be of interest. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(DAT)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 441\nColumns: 8\n$ name  <chr> \"Jocelyn Crawford\", \"Ava Sealander\", \"Kelly Ngo\", \"Helen Liu\", \"…\n$ year  <chr> \"2019\", \"2022\", \"2016\", \"2014\", \"2014\", \"2020\", \"2020\", \"2010\", …\n$ event <chr> \"50 FREE\", \"50 FREE\", \"50 FREE\", \"50 FREE\", \"50 FREE\", \"50 FREE\"…\n$ team  <chr> \"Athena\", \"Athena\", \"Athena\", \"Athena\", \"Athena\", \"Athena\", \"Ath…\n$ time  <dbl> 1409.00, 1411.00, 1429.00, 1451.00, 1456.00, 1457.00, 1457.00, 1…\n$ sec   <dbl> 1409.00, 1411.00, 1429.00, 1451.00, 1456.00, 1457.00, 1457.00, 1…\n$ min   <dbl> 23.483333, 23.516667, 23.816667, 24.183333, 24.266667, 24.283333…\n$ hour  <dbl> 0.39138889, 0.39194444, 0.39694444, 0.40305556, 0.40444444, 0.40…\n```\n:::\n:::\n\n\nLooks like some factor variables we can group by include `name`, `year`, `event`, and `team`.\n\n\n## **Summarize A (one) Specific Variable by Groups Using `group_by()`**\n\n### *A single summary metric*\n\nPerhaps you only want to obtain the `mean()` or the `sum()` or the `sd()` for a variable. If so, this is easiest.\n\n#### *Grouping by one variable*:\n\nThe data in cms-top-all-time-2023-swim.xlsx contain the top records for swimming events. You might be curious what `year` was the best of all time or what swimmer (e.g., `name`) has attained the most records of all time. There are different ways to accomplish this goal. \n\nOne approach that might be the most straight forward to new programmers is to mutate a constant count variable on each row which can be used to sum the counts for different groups.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  mutate(., count = 1) %>%         # mutate a new variable where all rows get a 1\n  group_by(., name) %>%            # group by the swimmer name\n  summarise(., count = sum(count)) # sum the count and assign it the name count\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 142 × 2\n   name            count\n   <chr>           <dbl>\n 1 A Breazeale         8\n 2 A Roeseler          2\n 3 Aaron Lutzker       6\n 4 Abel Sapirstein     1\n 5 Alec Vercruysse     4\n 6 Alex Mendoza        2\n 7 Alex Poltash        6\n 8 Allyson Yao         3\n 9 Amy Fuller          1\n10 Andrew Cox          4\n# ℹ 132 more rows\n```\n:::\n:::\n\n\nBy default, the data frame is arranged by the grouping variable (e.g., `name`). We can change the order of the rows by `count` using `arrange()` but this function by default sorts in an ascending manner. If you want a descending sorting, pass `count` to `desc()` to arrange the data frame in this way. We can also assign it to an object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNAME_count <- DAT %>%\n  mutate(., count = 1) %>%\n  group_by(., name) %>%\n  summarise(., count = sum(count)) %>%\n  arrange(., desc(count))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nNAME_count\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 142 × 2\n   name          count\n   <chr>         <dbl>\n 1 Michele Kee      11\n 2 Augusta Lewis    10\n 3 Matt Williams    10\n 4 Kelly Ngo         9\n 5 A Breazeale       8\n 6 Ava Sealander     8\n 7 Gary Simon        8\n 8 Marco Conati      8\n 9 Nic Tekieli       7\n10 Aaron Lutzker     6\n# ℹ 132 more rows\n```\n:::\n:::\n\n\nWe can see that the top counts of all time are by Michele Kee for a total of 11. Kudos to Michele!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nYEAR_count <- DAT %>%\n  mutate(., count = 1) %>%\n  group_by(., year) %>%\n  summarise(., count = sum(count)) %>%\n  arrange(., desc(count))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nYEAR_count\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 32 × 2\n   year  count\n   <chr> <dbl>\n 1 2022     81\n 2 2023     59\n 3 2020     41\n 4 2017     38\n 5 2014     27\n 6 2019     23\n 7 2013     22\n 8 2015     20\n 9 2016     17\n10 2018     16\n# ℹ 22 more rows\n```\n:::\n:::\n\n\nWe can see that the year with the most best are by 2022 for a total of 81. Hooray for 2022!\n\n\n#### *Grouping by two or more variables*:\n\nWe can also summarize both the teams as well in order to see the top swimmer by team. If you want to summarize more than one variable, pass them both in `group_by()`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nTEAM_NAME_count <- DAT %>%\n  mutate(., count = 1) %>%\n  group_by(., team, name) %>%\n  summarise(., count = sum(count)) %>%\n  arrange(., desc(count))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'team'. You can override using the\n`.groups` argument.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nTEAM_NAME_count\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 142 × 3\n# Groups:   team [2]\n   team   name          count\n   <chr>  <chr>         <dbl>\n 1 Athena Michele Kee      11\n 2 Athena Augusta Lewis    10\n 3 Stag   Matt Williams    10\n 4 Athena Kelly Ngo         9\n 5 Athena Ava Sealander     8\n 6 Stag   A Breazeale       8\n 7 Stag   Gary Simon        8\n 8 Stag   Marco Conati      8\n 9 Stag   Nic Tekieli       7\n10 Athena Ella Blake        6\n# ℹ 132 more rows\n```\n:::\n:::\n\n\n#### *Filtering rows and then grouping by one variable*:\n\nFor Athenas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nATHENA_NAME_count <- DAT %>%\n  mutate(., count = 1) %>%\n  filter(., team == \"Athena\") %>%\n  group_by(., name) %>%\n  summarise(., count = sum(count)) %>%\n  arrange(., desc(count))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nATHENA_NAME_count\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 67 × 2\n   name               count\n   <chr>              <dbl>\n 1 Michele Kee           11\n 2 Augusta Lewis         10\n 3 Kelly Ngo              9\n 4 Ava Sealander          8\n 5 Ella Blake             6\n 6 Jamee Mitchum          6\n 7 Katie Bilotti          6\n 8 Mackenzie Mayfield     6\n 9 Annika Jessen          5\n10 Jocelyn Crawford       5\n# ℹ 57 more rows\n```\n:::\n:::\n\nWe can see that the top counts of all time are by Michele Kee with a total of 11. Nice work Michele!\n\n\nAnd for Stags:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSTAG_NAME_count <- DAT %>%\n  mutate(., count = 1) %>%\n  filter(., team == \"Stag\") %>%\n  group_by(., name) %>%\n  summarise(., count = sum(count)) %>%\n  arrange(., desc(count))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSTAG_NAME_count\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 75 × 2\n   name          count\n   <chr>         <dbl>\n 1 Matt Williams    10\n 2 A Breazeale       8\n 3 Gary Simon        8\n 4 Marco Conati      8\n 5 Nic Tekieli       7\n 6 Aaron Lutzker     6\n 7 Alex Poltash      6\n 8 Blake Weber       6\n 9 Sam Willett       5\n10 Tom Harrison      5\n# ℹ 65 more rows\n```\n:::\n:::\n\n\nWe can see that the top counts of all time are by Matt Williams with 10. Go Matt!\n\n\nTo wrap up this example, sometimes working with separate data frames using `filter()` can provide more useful or manageable summaries.Perhaps you only want to obtain the `mean()` or the `sum()` or the `sd()` for a single variable. If so, this approach may be  easiest.\n\n\nIf you are curious, here is a story covering [\"How CMS teams became the Stags and Athenas\"](https://www.cmc.edu/magazine/fall-2016/how-cms-teams-became-stags-and-athenas).\n\n### *Multiple summary metrics*\n\nSometimes you need more than one summary statistic, for example, the `mean()` and the `sd()`. This is a little more complex to code.\n\n*Note:* In these code blocks, some arguments may be removed for readability.\n\n#### *Grouping by one variable*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  group_by(., event) %>%\n  summarise(., \n            sec_mean = mean(sec, na.rm = T),  \n            sec_median = median(sec, na.rm = T)\n            )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 22 × 3\n   event               sec_mean sec_median\n   <chr>                  <dbl>      <dbl>\n 1 100 BACK               3209.      3212.\n 2 100 BREAST             1725.      1696.\n 3 100 BRST-Relay Spl.    1710.      1678.\n 4 100 FLY                3158.      3165 \n 5 100 FLY-Relay Spl.     3135.      3152.\n 6 100 FREE               2917.      2908.\n 7 100 FREE-Relay Spl.    2888.      2896 \n 8 1000 FREE               601.       601.\n 9 1650 FREE               990.       991.\n10 200 BACK                116.       116.\n# ℹ 12 more rows\n```\n:::\n:::\n\n\nWe can also write the summary functions as a list inside `across()` along with passing `.names = \"{.col}_{.fn}\"` if you want the variables named automatically. This approach is more complex but is more flexible.\n\nWhen you want to summarize across multiple variables using a list of functions, you will want to make sure your `.fns` argument passes a function using a **{purrr}**-style lambda (e.g.,`~`) for that the function is applied across the variables. You will also want to edit `.names = \"{.col}_{.fn}\"` so that the naming is done automatically rather than hard coding the names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  group_by(., event) %>%\n  summarise(., across(.cols = \"sec\",\n                      .fns  = list(mean = ~mean(na.omit(.x)),\n                                   median = ~median(na.omit(.x))\n                                   ),\n                      .names = \"{.col}_{.fn}\"\n                      )\n            ) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 22 × 3\n   event               sec_mean sec_median\n   <chr>                  <dbl>      <dbl>\n 1 100 BACK               3209.      3212.\n 2 100 BREAST             1725.      1696.\n 3 100 BRST-Relay Spl.    1710.      1678.\n 4 100 FLY                3158.      3165 \n 5 100 FLY-Relay Spl.     3135.      3152.\n 6 100 FREE               2917.      2908.\n 7 100 FREE-Relay Spl.    2888.      2896 \n 8 1000 FREE               601.       601.\n 9 1650 FREE               990.       991.\n10 200 BACK                116.       116.\n# ℹ 12 more rows\n```\n:::\n:::\n\n\n#### *Grouping by two or more variables*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  group_by(., event, team) %>%\n  summarise(., \n            sec_mean = mean(sec, na.rm = T),  \n            sec_median = median(sec, na.rm = T)\n            )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'event'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 44 × 4\n# Groups:   event [22]\n   event               team   sec_mean sec_median\n   <chr>               <chr>     <dbl>      <dbl>\n 1 100 BACK            Athena   3421.      3436  \n 2 100 BACK            Stag     2996.      3032  \n 3 100 BREAST          Athena     64.0       64.2\n 4 100 BREAST          Stag     3386.      3394. \n 5 100 BRST-Relay Spl. Athena     63.6       64.1\n 6 100 BRST-Relay Spl. Stag     3356.      3363  \n 7 100 FLY             Athena   3365.      3369  \n 8 100 FLY             Stag     2950.      2968. \n 9 100 FLY-Relay Spl.  Athena   3332.      3326  \n10 100 FLY-Relay Spl.  Stag     2938.      2937  \n# ℹ 34 more rows\n```\n:::\n:::\n\n\nOr pass the list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  group_by(., event, team) %>%\n  summarise(., across(.cols = \"sec\",\n                      .fns  = list(mean = ~mean(na.omit(.x)),\n                                   median = ~median(na.omit(.x))\n                                   ),\n                      .names = \"{.col}_{.fn}\"\n                      )\n            ) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'event'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 44 × 4\n# Groups:   event [22]\n   event               team   sec_mean sec_median\n   <chr>               <chr>     <dbl>      <dbl>\n 1 100 BACK            Athena   3421.      3436  \n 2 100 BACK            Stag     2996.      3032  \n 3 100 BREAST          Athena     64.0       64.2\n 4 100 BREAST          Stag     3386.      3394. \n 5 100 BRST-Relay Spl. Athena     63.6       64.1\n 6 100 BRST-Relay Spl. Stag     3356.      3363  \n 7 100 FLY             Athena   3365.      3369  \n 8 100 FLY             Stag     2950.      2968. \n 9 100 FLY-Relay Spl.  Athena   3332.      3326  \n10 100 FLY-Relay Spl.  Stag     2938.      2937  \n# ℹ 34 more rows\n```\n:::\n:::\n\n\n\n## **Summarizing Multiple Variables by Groups Using `group_by()`**\n\nSo far, we have shown how to summarize a single variable either with or without grouping by levels of another variable. Summaries, however, are often done for multiple variables in data frame. For example, you might want to obtain the `mean()` for multiple variables or obtain the `mean()` and the `max()` (or some other summary statistic) for multiple variables. The following examples prepare you for such tasks.\n\n### *A single summary metric*\n\n#### *Grouping by one variable*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  group_by(., event) %>%\n  summarise(., across(.cols = c(\"sec\", \"min\"),\n                      .fns = ~mean(.x, na.rm = T),\n                      .names = \"{.col}_{.fn}\"\n                      )\n            ) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 22 × 3\n   event               sec_1 min_1\n   <chr>               <dbl> <dbl>\n 1 100 BACK            3209. 53.5 \n 2 100 BREAST          1725. 28.8 \n 3 100 BRST-Relay Spl. 1710. 28.5 \n 4 100 FLY             3158. 52.6 \n 5 100 FLY-Relay Spl.  3135. 52.2 \n 6 100 FREE            2917. 48.6 \n 7 100 FREE-Relay Spl. 2888. 48.1 \n 8 1000 FREE            601. 10.0 \n 9 1650 FREE            990. 16.5 \n10 200 BACK             116.  1.94\n# ℹ 12 more rows\n```\n:::\n:::\n\n\n#### *Grouping by two or more variables*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  group_by(., event, team) %>%\n  summarise(., across(.cols = c(\"sec\", \"min\"),\n                      .fns = ~mean(.x, na.rm = T),\n                      .names = \"{.col}_{.fn}\"\n                      )\n            ) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'event'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 44 × 4\n# Groups:   event [22]\n   event               team    sec_1 min_1\n   <chr>               <chr>   <dbl> <dbl>\n 1 100 BACK            Athena 3421.  57.0 \n 2 100 BACK            Stag   2996.  49.9 \n 3 100 BREAST          Athena   64.0  1.07\n 4 100 BREAST          Stag   3386.  56.4 \n 5 100 BRST-Relay Spl. Athena   63.6  1.06\n 6 100 BRST-Relay Spl. Stag   3356.  55.9 \n 7 100 FLY             Athena 3365.  56.1 \n 8 100 FLY             Stag   2950.  49.2 \n 9 100 FLY-Relay Spl.  Athena 3332.  55.5 \n10 100 FLY-Relay Spl.  Stag   2938.  49.0 \n# ℹ 34 more rows\n```\n:::\n:::\n\n\n### *Multiple summary metrics*\n\nAnd if you need to summarize using multiple metrics, then pass the list into `.fns`:\n\n#### *Grouping by one variable*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  group_by(., event) %>%\n  summarise(., across(.cols = c(\"sec\", \"min\"),\n                      .fns  = list(mean = ~mean(na.omit(.x)),\n                                   median = ~median(na.omit(.x))\n                                   ),\n                      .names = \"{.col}_{.fn}\"\n                      )\n            ) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 22 × 5\n   event               sec_mean sec_median min_mean min_median\n   <chr>                  <dbl>      <dbl>    <dbl>      <dbl>\n 1 100 BACK               3209.      3212.    53.5       53.5 \n 2 100 BREAST             1725.      1696.    28.8       28.3 \n 3 100 BRST-Relay Spl.    1710.      1678.    28.5       28.0 \n 4 100 FLY                3158.      3165     52.6       52.8 \n 5 100 FLY-Relay Spl.     3135.      3152.    52.2       52.5 \n 6 100 FREE               2917.      2908.    48.6       48.5 \n 7 100 FREE-Relay Spl.    2888.      2896     48.1       48.3 \n 8 1000 FREE               601.       601.    10.0       10.0 \n 9 1650 FREE               990.       991.    16.5       16.5 \n10 200 BACK                116.       116.     1.94       1.93\n# ℹ 12 more rows\n```\n:::\n:::\n\n\n#### *Grouping by two or more variables*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  group_by(., event, team) %>%\n  summarise(., across(.cols = c(\"sec\", \"min\"),\n                      .fns  = list(mean = ~mean(na.omit(.x)),\n                                   median = ~median(na.omit(.x))\n                                   ),\n                      .names = \"{.col}_{.fn}\"\n                      )\n            ) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'event'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 44 × 6\n# Groups:   event [22]\n   event               team   sec_mean sec_median min_mean min_median\n   <chr>               <chr>     <dbl>      <dbl>    <dbl>      <dbl>\n 1 100 BACK            Athena   3421.      3436      57.0       57.3 \n 2 100 BACK            Stag     2996.      3032      49.9       50.5 \n 3 100 BREAST          Athena     64.0       64.2     1.07       1.07\n 4 100 BREAST          Stag     3386.      3394.     56.4       56.6 \n 5 100 BRST-Relay Spl. Athena     63.6       64.1     1.06       1.07\n 6 100 BRST-Relay Spl. Stag     3356.      3363      55.9       56.0 \n 7 100 FLY             Athena   3365.      3369      56.1       56.2 \n 8 100 FLY             Stag     2950.      2968.     49.2       49.5 \n 9 100 FLY-Relay Spl.  Athena   3332.      3326      55.5       55.4 \n10 100 FLY-Relay Spl.  Stag     2938.      2937      49.0       49.0 \n# ℹ 34 more rows\n```\n:::\n:::\n\n\nDepends on the order in `group_by()`, so change the order:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  group_by(., team, event) %>%\n  summarise(., across(.cols = \"sec\",\n                      .fns  = list(mean = ~mean(na.omit(.x)),\n                                   n = ~length(na.omit(.x))\n                                   ),\n                      .names = \"{.col}_{.fn}\"\n                      )\n            ) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'team'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 44 × 4\n# Groups:   team [2]\n   team   event               sec_mean sec_n\n   <chr>  <chr>                  <dbl> <int>\n 1 Athena 100 BACK              3421.     10\n 2 Athena 100 BREAST              64.0    10\n 3 Athena 100 BRST-Relay Spl.     63.6    10\n 4 Athena 100 FLY               3365.     10\n 5 Athena 100 FLY-Relay Spl.    3332.     10\n 6 Athena 100 FREE              3115.     10\n 7 Athena 100 FREE-Relay Spl.   3088.     10\n 8 Athena 1000 FREE              625.     10\n 9 Athena 1650 FREE             1031.     10\n10 Athena 200 BACK               124.     10\n# ℹ 34 more rows\n```\n:::\n:::\n\n\nNotice the change in the order of the column variables. But remember, you can change the order later using `select()` and/or `relocate()`.\n\n\n\n## **Summarizing Multiple Variables With Reference by Name`**\n\n### *Variables that are numeric*\n\nYou can also pass variables that are a certain type, like numeric. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  group_by(., team, event) %>%\n  summarise(., across(.cols = where(is.numeric), \n                      .fns = ~mean(.x, na.rm = TRUE), \n                      .names = \"{.col}\")\n            )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'team'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 44 × 6\n# Groups:   team [2]\n   team   event                 time    sec   min   hour\n   <chr>  <chr>                <dbl>  <dbl> <dbl>  <dbl>\n 1 Athena 100 BACK            3421.  3421.  57.0  0.950 \n 2 Athena 100 BREAST            64.0   64.0  1.07 0.0178\n 3 Athena 100 BRST-Relay Spl.   63.6   63.6  1.06 0.0177\n 4 Athena 100 FLY             3365.  3365.  56.1  0.935 \n 5 Athena 100 FLY-Relay Spl.  3332.  3332.  55.5  0.926 \n 6 Athena 100 FREE            3115.  3115.  51.9  0.865 \n 7 Athena 100 FREE-Relay Spl. 3088.  3088.  51.5  0.858 \n 8 Athena 1000 FREE            625.   625.  10.4  0.174 \n 9 Athena 1650 FREE           1031.  1031.  17.2  0.286 \n10 Athena 200 BACK             124.   124.   2.07 0.0345\n# ℹ 34 more rows\n```\n:::\n:::\n\n\n### *Variables by pattern match*\n\nThis approach is fun, especially if you have already named variables in ways that make selection really useful. This data frame is constrained a bit so the examples may be silly.\n\n\n#### *Using starts_with()*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  group_by(., team, event) %>%\n  summarise(., across(.cols = starts_with(\"t\"),\n                      .fns  = list(mean = ~mean(na.omit(.x)),\n                                   n = ~length(na.omit(.x))\n                                   ),\n                      .names = \"{.col}_{.fn}\"\n                      )\n            ) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'team'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 44 × 4\n# Groups:   team [2]\n   team   event               time_mean time_n\n   <chr>  <chr>                   <dbl>  <int>\n 1 Athena 100 BACK               3421.      10\n 2 Athena 100 BREAST               64.0     10\n 3 Athena 100 BRST-Relay Spl.      63.6     10\n 4 Athena 100 FLY                3365.      10\n 5 Athena 100 FLY-Relay Spl.     3332.      10\n 6 Athena 100 FREE               3115.      10\n 7 Athena 100 FREE-Relay Spl.    3088.      10\n 8 Athena 1000 FREE               625.      10\n 9 Athena 1650 FREE              1031.      10\n10 Athena 200 BACK                124.      10\n# ℹ 34 more rows\n```\n:::\n:::\n\n\n#### *Using `&` for complex selection*\n\nYou obviously cannot calculate numeric metrics for character variables. But how might you select variables that contain a certain character pattern but are also numeric? You cannot nest these functions (e.g., `where(is.numeric(contains(\"pattern\")))`). You can, however, pass the functions separately.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT %>%\n  group_by(., team, event) %>%\n  summarise(., across(.cols = contains(\"e\") & where(is.numeric),\n                      .fns  = list(mean = ~mean(na.omit(.x)),\n                                   n = ~length(na.omit(.x))\n                                   ),\n                      .names = \"{.col}_{.fn}\"\n                      )\n            ) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'team'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 44 × 6\n# Groups:   team [2]\n   team   event               time_mean time_n sec_mean sec_n\n   <chr>  <chr>                   <dbl>  <int>    <dbl> <int>\n 1 Athena 100 BACK               3421.      10   3421.     10\n 2 Athena 100 BREAST               64.0     10     64.0    10\n 3 Athena 100 BRST-Relay Spl.      63.6     10     63.6    10\n 4 Athena 100 FLY                3365.      10   3365.     10\n 5 Athena 100 FLY-Relay Spl.     3332.      10   3332.     10\n 6 Athena 100 FREE               3115.      10   3115.     10\n 7 Athena 100 FREE-Relay Spl.    3088.      10   3088.     10\n 8 Athena 1000 FREE               625.      10    625.     10\n 9 Athena 1650 FREE              1031.      10   1031.     10\n10 Athena 200 BACK                124.      10    124.     10\n# ℹ 34 more rows\n```\n:::\n:::\n\n\n\n# **Summary**\n\nYou can see that summarizing data can be fun, interesting, simple, but sometimes complex. The examples above are only limited to selecting variables by name. Of course, you can `summarize()` `across()` variables that `contain()` characters or that `starts_with()` some characters or even across variables that `is.numeric()` (pardon the grammar) by pairing these functions with the \n\n\n\n## **A Functional Approach**\n\nYou can also throw your summaries into functions if you wish. We will create a new object that is a function object. We need to give it a name and we need to define arguments to make the function operate. We will want to make sure we have numeric variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarizer <- function(data, \n                       cols = NULL, \n                       ...\n                       ) {\n  data %>%\n    group_by(...) %>%\n    summarise(., across(.cols = {{cols}} & where(is.numeric),\n                     .fns = list(\n                          mean = ~mean(.x, na.rm = TRUE),\n                          sd   = ~sd(.x, na.rm = TRUE)\n                          ), \n                     .names = \"{col}_{fn}\")\n              )\n}\n```\n:::\n\n\nTest the function:\n\nWithout grouping:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarizer(DAT, cols = contains(\"e\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 4\n  time_mean time_sd sec_mean sec_sd\n      <dbl>   <dbl>    <dbl>  <dbl>\n1     1310.   1225.    1309.  1226.\n```\n:::\n:::\n\n\nWith grouping:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarizer(DAT, cols = c(min, hour), event)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 22 × 5\n   event               min_mean min_sd hour_mean hour_sd\n   <chr>                  <dbl>  <dbl>     <dbl>   <dbl>\n 1 100 BACK               53.5   3.76     0.891  0.0626 \n 2 100 BREAST             28.8  28.4      0.479  0.473  \n 3 100 BRST-Relay Spl.    28.5  28.1      0.475  0.469  \n 4 100 FLY                52.6   3.63     0.877  0.0605 \n 5 100 FLY-Relay Spl.     52.2   3.44     0.871  0.0573 \n 6 100 FREE               48.6   3.43     0.810  0.0571 \n 7 100 FREE-Relay Spl.    48.1   3.46     0.802  0.0576 \n 8 1000 FREE              10.0   0.432    0.167  0.00719\n 9 1650 FREE              16.5   0.728    0.275  0.0121 \n10 200 BACK                1.94  0.136    0.0324 0.00227\n# ℹ 12 more rows\n```\n:::\n:::\n\n\n\nAnd of course, when you really get excited, you could add functions so that you can perform different metrics. When you are done, you can save your favorite function to a file you can `source()`. \n\n\n# **Session Information**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 11 x64 (build 22621)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/Los_Angeles\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] lubridate_1.9.2 stringr_1.5.0   dplyr_1.1.2     magrittr_2.0.3 \n\nloaded via a namespace (and not attached):\n [1] bit_4.0.5         archive_1.1.5     jsonlite_1.8.7    crayon_1.5.2     \n [5] compiler_4.3.1    tidyselect_1.2.0  Rcpp_1.0.11       zip_2.3.0        \n [9] parallel_4.3.1    yaml_2.3.7        fastmap_1.1.1     here_1.0.1       \n[13] readr_2.1.4       R6_2.5.1          generics_0.1.3    openxlsx_4.2.5.2 \n[17] knitr_1.43        htmlwidgets_1.6.2 tibble_3.2.1      rprojroot_2.0.3  \n[21] pillar_1.9.0      tzdb_0.4.0        rlang_1.1.1       utf8_1.2.3       \n[25] stringi_1.7.12    xfun_0.40         bit64_4.0.5       timechange_0.2.0 \n[29] cli_3.6.1         withr_2.5.0       digest_0.6.33     vroom_1.6.3      \n[33] rstudioapi_0.15.0 hms_1.1.3         lifecycle_1.0.3   vctrs_0.6.3      \n[37] evaluate_0.21     glue_1.6.2        fansi_1.0.4       rmarkdown_2.24   \n[41] tools_4.3.1       pkgconfig_2.0.3   htmltools_0.5.6  \n```\n:::\n:::\n",
    "supporting": [
      "07_data_subsets_and_summaries_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}